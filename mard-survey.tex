%\documentclass[a4paper,10pt]{article}
\documentclass[acmcsur,acmnow]{acmtrans2m}
%\documentclass[acmtocl,acmnow]{acmtrans2m}

%\acmVolume{V}
%\acmNumber{N}
%\acmYear{YY}
%\acmMonth{Month}

% packages
\usepackage[utf-8]{inputenc}
\usepackage{paralist}
\usepackage{subfigure}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{color,soul}
\usepackage{longtable}
\usepackage{pdflscape}

% definitions
\newtheorem{theorem}{Theorem}[section]
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newdef{definition}[theorem]{Definition}
\newdef{remark}[theorem]{Remark}

%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{definition}[theorem]{Definition}

%\textwidth      6.5in
%\textheight     9.2in
%\oddsidemargin  -0.5cm
%\evensidemargin -0.5cm
%\parindent      0pt              
%\topmargin      -0.3in
%\headsep        20pt
%
%\parskip        5pt
%\parindent      10pt

\markboth{}{}{}

\title{Alleviating the Topology Mismatch Problem in Unstructured and Structured
Overlay Networks: A Survey}

\author{
VASSILIS S. MOUSTAKAS\\\emph{Department of Informatics and Telecommunications}\\\emph{National and Kapodistrian University of Athens}\\
H\"USEYIN AKCAN\\\emph{Department of Software Engineering}\\\emph{Izmir University of Economics}\\
MEMA ROUSSOPOULOS\\\emph{Department of Informatics and Telecommunications}\\\emph{National and Kapodistrian University of Athens}\\
AND\\
ALEX DELIS\\\emph{Department of Informatics and Telecommunications}\\\emph{National and Kapodistrian University of Athens}\\
%  Vassilis Moustakas$^1$, H\"useyin Akcan$^2$, Mema Roussopoulou$^1$ and Alex
%Delis$^1$\\
%  $^1$Department of Informatics and Telecommunications,\\
%  National and Kapodistrian University of Athens\\
%  \mbox{\texttt{\{b.moystakas, mema, ad\}@di.uoa.gr}}\\
%  $^2$Department of Software Engineering,\\
%  Izmir University of Economics, Izmir, Turkey \\
%  \mbox{\texttt{huseyin.akcan@ieu.edu.tr}}
}

\begin{abstract}
Peer-to-peer (P2P) systems is a rapidly growing application architecture. The
overlay network abstraction on top of a best-effort infrastructure provides a
powerful tool to realize a plethora of ever-wanted exotic features like
anonymity, high availability and robustness, load balancing, quality-of-service
(QoS) at the application layer and many more. Unfortunately weaknesses of early
effectuations constrained applications from unleashing the full potential of the
paradigm. One of them is the topology mismatch problem between the overlay and
the physical underlying network, a problem that imposes a huge amount of
unnecessary stress to the network resources and, thus, impede applications from
scaling. In this survey we investigate on the recent research developments
towards the alleviation of this problem, in both unstructured and structured
overlay architectures. We visit the various algorithms available in the
lietrature, focusing on the presentation of how each of them tries to tackle the
problem. Additionally, we provide a finer grained categorisation of the
approaches based on the generic type of methodology they use in order to
accomplish this goal.
% TODO: Review this after the comparison sections are fixed.
Finally we discuss the advantages, disadvantages and novelties introduced by the
algotithms and offer pictorial comparisons for them in order to further
strengthen and organise understanding of the information and knowledge cited, in
an attempt to make this survey a one-stop-shop reference for anyone interested
in the topic, from researchers and students, to system architects and
developers.
\end{abstract}

\category{}{}{}

\terms{Topology mismatch, distributed, peer-to-peer, P2P, overlay}

\keywords{Topology mismatch problem, distributed algorithm, peer-to-peer
architecture, overlay network }

\begin{document}

\begin{bottomstuff}
SAY SOMETHING COOL HERE...
\end{bottomstuff}

\maketitle

\input{intro}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% start
%TODO: Maybe this section should be reviewed or deleted or go to another section
%Studying the behaviour of the various peer-to-peer schemes
%\cite{matei_mapgnutella_2002, lv_randomwalks_2002, merugu_str2unstr_2003}
%showed that the ad-hoc network topology of unstructured overlay networks that
%preserve \emph{Power Law} and \emph{Small World} characteristics\footnote{Power
%Law describes the node degree while the Small World describes characteristics
%of path length and clustering coefficient. The clustering coefficient for a
%node $\upsilon$ in a graph $G = \left( V, E \right)$ is defined as the ratio of
%the existing connections between $\upsilon$'s neighbouring nodes to $\gamma
%\times \left( \gamma - 1 \right)$, where $\gamma$ is the number of neighbouring
%nodes of $\upsilon$. High cluster coefficient means that neighbouring nodes of
%any node $\upsilon$ likely connect one another.} \cite{faloutsos_powerlaw_1999,
%saroiu_measurefileshare_2002} offer a more promising approach. Particularly:
%\begin{itemize}
%  \item Peer-to-peer clients are extremely \emph{transient}. Unstructured
%systems can have high maintenance traffic in delivering messages, updating the
%mapping, discovering failures and replicating lost data or pointers, making
%them insufficient on highly volatile networks.
%  \item \emph{Keyword searches} versus \emph{exact-match queries}. In DHTs
%there is a tight control between the data placement and the topology of the
%network. For this reason it is hard to efficiently support partially matched
%queries while Gnutella and other similar systems effortlessly support keyword
%searches and other complex queries since the mechanism is realized locally, on
%a node-by-node basis.
%  \item Popular content is located at multiple peers and thus it is more likely
%for a flooding-based search to return results. DHTs, on the other hand, fit
%better in the systems which require ability to reliably locate content, even in
%the extreme case that only a single-copy exists in the network.
%\end{itemize}
% end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: how 
%For this reasons, efforts have been placed for optimizing the efficiency of
%decentralized unstructured peer-to-peer networks. Research mainly focuses on
%\begin{inparaenum}[\itshape i\upshape)]
%  \item reducing unnecessary, redundant communication traffic, and
%  \item exploiting physical locality to reduce communication response.
%\end{inparaenum}
%The goal can be achieved at, both, the application-level network as well as the
%underlying physical one. In the first case by refining the message relay
%techniques, while in the second one, by adaptively reconstructing the
%application network to map as well as possible to the the physical network.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{The Topology Mismatch Problem}

%%%%%%%
%%%%%%% TODO: NEEDS REWORDING
%%%%%%% Additional Material
%%%%%%%
%%%%%%%
%%%%%%%
% P4P [16],instead, aimed to provide a general framework for P2P
%applications by developing ISP-application interfaces so that
%application software can use the network layer information,
%such as congestion status and network topology, for better
%performance and resource utilization.

%P4P [37] project attempts to address
%the problem through custom trackers, both for ISPs and P2P
%systems, using an interface based on a primal-dual decomposition
%of an optimization problem. This interface design simplifies
%the realization of traffic-engineering objectives from each partiesâ€™
%perspective and ensures the extensibility of the approach. Through
%simulation-based studies and limited experimental deployments,
%these collaborative approaches have been shown to effectively
%reduce network costs while minimally impacting application performance.
%A clear advantage of these proposals is that they
%allow ISPs to incorporate aggregated traffic policies in their tracker
%recommendations (e.g., a particular traffic balance ratio between
%peering providers). However, all of them require deployments
%of oracles for each participating ISP and their effectiveness is
%ultimately predicated on their adoption by P2P applications and a
%trust relationship between P2P users and their ISPs.

% TODO: Taxomize the approaches that have been proposed in the literature
% for unstructured and structured overlay networks
% UNDER CONSTRUCTION
% VERY IMPORTANT SECTION
%\section{Taxonomy}
%
%% TODO: Unstructured
%% UNDER CONSTRUCTION
%Several overlay protocols for dealing with the problems derived from the
%topology mismatch problem have been proposed in the literature. Each
%implementation has different goals but all share some common ground on the
%aspect of the network functionality they focus on, in order to achieve them. In
%this section, the general taxonomy used throughout this paper to categorize the
%algorithms based on their functionality is presented.  The brief description of
%each category and sub-category is stated below.
%
%{\sethlcolor{yellow}\hl{CITE this paper {\cite{liu_ltm_2004}}}}
%
%\subsection{Forwarding based}
%
%Forwarding based methodology is generally adapted by distributed unstructured
%overlay systems. In this approach, a peer selects only a subset of its
%neighbours to re-broadcast query messages. The selection is made using one or a
%combination of various statistical metrics. Examples of such metrics are the
%number of responses received by a neighbour or the connection latency of the
%link between the nodes, etc. The forwarding based approach enhances search
%efficiency but has also several drawbacks. First, the search scope is reduced
%drastically.  Expanding the search scope, on the other hand, is no easy task
%because the overhead of forming multicast trees is proportional to the multicast
%group size.  Second, forwarding based schemes do not consider dynamic joining
%and leaving of peers so they do not scale well on dynamic environments.
%
%\subsection{cache based} 
%
%Caching based protocols are effectively used to reduce traffic costs and
%response times. The caching policy varies depending on the way protocol handles
%the index and the content. Centralized P2P systems use central index servers,
% while local caching systems, such as KazaA, use super peers
%to cache indices in a distributed way. Content caching is also possible in P2P
%systems, where nodes cache the forwarded content for further retrievals.
%Although caching has the above mentioned advantages,  duplication
%of messages still exist, which limits the scalability of these approaches.
%Therefore, cache based approaches are analyzed in the following categories:
%  \begin{itemize}
%    \item \emph{data index caching},
%    \item \emph{content index caching},
%    \item \emph{centralized}, and
%    \item \emph{local}.
%  \end{itemize}
%
%\subsection{overlay optimization based} 
%
%The overlay optimization based protocols modify the topology of the P2P network
%using various techniques. These approaches include creating spanning trees using 
%connection graphs, creating cluster of physically close nodes, or using latency
%information to detect proximity. The brief description of each category is
%presented below:
%
%  \begin{itemize}
%    \item \emph{Spanning tree based}. These approaches construct of a rich graph
%    based on the network connections and build minimum spanning tree on the
%    graphs, causing large traffic overhead to the system
%    \cite{chu_esm_2000,chu_esm_2002}.
%
%    \item \emph{Cluster based}. These approaches select to link physically
%    closer nodes with each other, therefore shrink the search scope
%    significantly while mapping accuracy is not always guaranteed.
%
%    \item \emph{Minimum latency first}. Use of latency as a metric to calculate
%    distance among peers. They require global latency information
%    ``landmarks''\footnote{Measuring latency between peers and stable Internet
%    servers.}.
%
%  \end{itemize}
%
%
%% TODO: Structured
%% UNDER CONSTRUCTION
%\subsection{proximity based}
%Xu \textit{et al.} \cite{xu_globstate_2003} state that there are three ways generating proximity information
%\begin{itemize}
% \item Expanding Ring Search\\
%Expanding ring search can be of two forms. First it can utilize the multicast
%infrastructure in the underlying network in order to emit its messages.
%Unfortunately such infrastructures are not widely deployed thus the
%implementations of this way of generating proximity information is limited to
%blindly flooding the neighbourhood to obtain reasonable results.
%
% \item Heuristics\\
%Heuristics are used in order to reduce the blindness of the expanding ring
%search and make realizations more efficient and effective. Unfortunately a
%common problem of all heuristic approaches is the local minimum pitfall in which
%the search might be caught into.
%
% \item Landmark Binning\\
%Landmark clustering is based on the view that nodes with similar distances to a
%set of predefined well-known landmark nodes are pretty likely of being close to
%each other. But this approach has its weaknesses as well, such as the fact that
%is a rather coarse grained approximation, therefore not particularly well suited
%for differentiating nodes within close distance to each other.
%
%\end{itemize}
%
%Castro \textit{et al.} \cite{castro_proximitydht_2002,castro_topawareroute_2002} on
%the other hand, comment on the three basic approaches in exploiting proximity
%in DHT protocols suggested by Ratnasamy \textit{et al.} \cite{ratnasamy_openq_2002}.
%These are:
%
%\begin{itemize}
% \item Geographic Layout\\
%The node IDs are assigned in such a way that nodes close by in the physical
%network topology, be close in the node ID space as well. Implementations that
%work relatively well with this approach have been incorporated into CAN. Nodes
%measure the RTT between themselves and a set of landmarks in order to match the
%CAN space as much as possible to the physical one. Unfortunately, the approach
%requires well known landmark servers and for that matter is  not fully
%self-organizing which can further lead to imbalanced node distribution. On
%other DHTs, such as Chord or Pastry, another problem emerges.  To gain fault
%tolerant properties, these protocols, replicate key-value pairs on neighbouring
%(in the ID space) nodes. When a proximity-based node ID assignment has been
%used, the needed failure resilience is undermined by the fact that close by
%nodes are more likely to suffer collective failures.
%
% \item Proximity Routing\\
%Proximity routing does not require routing tables be built using any knowledge
%about network proximity. On the other hand it exploits such knowledge in order
%to choose the best next hop during routing a message. This approach 
%balances between choosing the node that will further progress the routing
%towards the destination and choosing the closest entry in the routing table, in
%terms of network proximity. Thus, it is relatively less effective than
%geographical layout when applied to CAN(-like) implementations. Moreover, the
%technique has been incorporated into a version of Chord (TODO: PChord |
%additionally check whether this is true) causing an increase on the overhead of
%node joins and the size as well as maintenance cost of finger tables.
%\cite{dabek_cfs_2001} proposes a server selection scheme for the Chord DHT, on
%the domain of proximity routing selection. In \emph{CFS}, each node predicts
%the entire lookup latency as a function of the total number of nodes and the
%average overlay next routing peer. The problem is that it is very difficult to
%have a clear picture on the total number of nodes and the average hop latency
%from the local. This leads to rough estimations that consequently decreases
%overall performance.
%
% \item Proximity Neighbour Selection\\
%Finally, the third approach, constructs the routing tables using proximity
%knowledge. Tapestry and Pastry's mechanisms of routing table
%maintenance try to minimize the distance to nodes appearing in a peer's routing
%table. Since routing is based on longest node ID prefix match, messages 
%are gradually forwarded to nearby nodes at each routing step.
%\cite{castro_proximityp2p_2002} argues on how Pastry exploits proximity
%neighbour selection in order to create a scheme that is (more) location-aware
%compared to the other well-known DHTs (CAN, Chord).
%
%\end{itemize}
%
%{\sethlcolor{yellow}\hl{
%HA: Possible criteria: based on which protocol (eg Gnutella, CAN etc), peer
%selection (topology selection, cluster, cache etc), supports dynamic update,
%runtimes}}
%%\textbf{Algorithm} & \textbf{Overlay structure} & \textbf{Forwarding} &
%\textbf{Cache} & \textbf{Overlay optimization} & \textbf{Proximity information}
%& \textbf{Base protocol} & \textbf{Dynamic update} & \textbf{Runtime} \\
%
%
%{\sethlcolor{yellow}\hl{
%HA: Possible criteria2: Overlay optimization structure, base protocol (eg
%Gnutella, CAN etc), dynamic update, runtimes, scalability}}
%
%{\sethlcolor{yellow}\hl{
%HA: maybe add also the year of publication, and see if there is a pattern in
%terms of the method and the year??}}

\input{unstructured}


\input{structured}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{The Algorithms}
%Having understood the nature of the problem that peer-to-peer architecture face, this section starts the discussion of the academic work that has been conducted in the field the last few years. What follows this introduction, does not claim to be a thorough citation of all known protocols that are available out there, but instead, a carefull selection of those that left a distinctive fingerprint contribution in the efforts of the research community to alleviate the topology mismatch problem.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% UNSTRUCTURED
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsection{Narada}
%
%\paragraph*{}
%\emph{End System Multicast} \cite{chu_esm_2000,chu_esm_2001,chu_esm_2002} as well as other  proposes an architecture, where end-systems implement all multicast related functionality (including membership management and packet replication). In \emph{Narada}, the protocol developed in the paper's context, end-systems
%\begin{inparaenum}[\itshape i\upshape)]
%  \item self-organize, in a fully distributed manner,
%  \item into an efficient overlay structure, both from the network and the application perspective,
%  \item with self improving properties,
%  \item adapting to network dynamics\footnote{Long-term variations in Internet path characteristics (i.e. bandwidth, latency e.t.c.)}.
%\end{inparaenum}
%
%\paragraph*{}
%What Narada really does is to construct overlay spanning trees in a two-step process:
%\begin{enumerate}
%  \item It builds a richer connected graph \footnote{ENarada \cite{li_enarada_2008} used Gossip protocol for the construction}, termed a \emph{mesh}, while trying to ensure a couple of desired performance properties:
%    \begin{itemize}
%      \item path quality between any pair of members should be comparable to the quality of the unicast path between them, and
%      \item each member should have a limited number of neighbours on the mesh.
%    \end{itemize}
%
%  \item It computes minimum spanning trees out of the mesh, each rooted at the corresponding source member.
%\end{enumerate}
%
%\paragraph*{}
%Narada incrementally improves the quality of the mesh by adding and dropping overlay links. Members probe each other at random and new links are added depending on what is the gain in doing so. On the other hand, participants, continuously  monitor the utility of existing links, and drop them if they are found to be not usefull.
%
%\paragraph*{}
%Narada protocol achieves relatively good performance for small and medium sized groups involving tens to hundreds of members. This is not, by no means, what a contemporary peer-to-peer system needs to be characterized as scalable, but this work is considered pioneering\footnote{Another similar approach is \emph{Scattercast}\cite{chawathe_scattercast_2000}}, in that it was the first to have conducted a detailed Internet evaluation to analyse and demonstrate the feasibility of an overlay-based, application layer, multicast architecture that can dynamically adapt to bandwidth and latency properties of the physical underlying infrastructure.
%
%\subsection{Gia}
%
%\paragraph*{}
%\emph{Gia} \cite{chawathe_gia_2003} is a decentralized unstructured peer-to-peer file sharing system with the following characteristics:
%\begin{inparaenum}[\itshape i\upshape)]
%  \item replaces Gnutella's flooding with random walks \cite{lv_randomwalks_2002},
%  \item recognizes the importance of overlay network's topology, while using the random walks, and exploits it by incorporating a topology adaptation algorithm,
%  \item introduces a token-based flow control mechanism, and
%  \item detects the significant heterogeneity in peer bandwidth, processing power, disk speed e.t.c. and takes advantage of it.
%\end{inparaenum}
%
%\paragraph*{}
%More specifically, there are four key components in the design of \emph{Gia} which are summarized bellow:
%\begin{enumerate}
%  \item A \emph{dynamic topology adaptation} protocol that puts participating nodes within short reach of high capacity nodes so that these \emph{high-degree} nodes, which due to their high connectivity receive most of the queries, actually have the capacity to handle them.
%  \item An \emph{active flow control} scheme is used to avoid overloaded hot-spots. Heterogeneity is detected and flow control tokens are given to nodes based on the available capacity.
%  \item Every node maintains pointers to to the content that is offered by their immediate neighbours, creating a \emph{one-hop replication} of pointers, scheme.
%  \item A \emph{search protocol} based on random walks, that is biased towards directing queries to high-capacity nodes that are typically best able to answer these queries.
%\end{enumerate}
%
%\subsection{Adaptive Overlay Topology Optimization}
%
%\paragraph*{}
%\emph{Adaptive Overlay Topology Optimization (AOTO)} \cite{liu_auto_2003} is an algorithm for building an overlay multicast tree among each source node and its direct logical neighbours in order to alleviate the mismatching problem while providing a larger query coverage range. It includes the steps of
%\begin{inparaenum}[\itshape i\upshape)]
%  \item \emph{Selective Flooding (SF)}, and
%  \item \emph{Active Topology (AT)}
%\end{inparaenum}
%which are furtherlly discussed in the following paragraphs.
%
%\paragraph*{Selective Flooding (SF)}
%Instead of flooding to all neighbours, SF builds an overlay multicast tree among each peer and its immediate logical neighbours. This reduces overall message burden to the network by making some neighbours non-flooding. The tree is formed using a minimum spanning tree algorithm. For this reason a peer needs to know the costs to all its logical neighbours (e.g. the network delay) as well as between any pair of neighbours. Additional, cost probing, messages need to be added to the original messages defined by the Gnutella protocol.
%
%LTM's SF effectiveness has be proven to be detached from the different physical or overlay topologies. On the other hand, SF is more effective with large number of logical neighbours. It can reach an average optimization rate of 87.4 percent on a logical topology with an average of 30 logical neighbours. 
%
%\paragraph*{Active Topology (AT)}
%At this step the overlay topology is reorganized. Each peer, independently, makes optimizations in the overlay network to alleviate topology mismatching by replacing non-flooding neighbours, with closer nodes. The approach incorporated by the paper is called \emph{Randomized AT} algorithm which picks up a candidate peer at random among the non-flooding neighbour's neighbours. Whenever a new neighbour cost table is received or there is a change of neighbours, the source peer has to re-calculate the multicast tree and apply the randomized AT algorithm.
%
%Different numbers of average logical neighbours has little to do with the effectiveness of AT. If the source has $n$ non-flooding peers, there are $n$ potential neighbour replacements. The overhead to exhaust all $n$ possible replacements can be high, so in practice, after each replacement the source peer can decide whether it needs to find another candidate peer. This is done by computing the cost improvement ratio greater than some predefined termination threshold. The larger the threshold, the slower, in the number of optimization steps, the reduction of the normalized average distance. As a whole the average response time is significantly reduced when more optimization steps taken.
%
%\subsection{Location-aware Topology Matching}
%
%\paragraph*{}
%\emph{Location-aware topology matching} or \emph{LTM} \cite{liu_ltm_2004}, is an algorithm of building an efficient overlay by disconnecting low productive connections and choosing physically closer nodes as logical neighbours while still retaining the search scope and reducing response time of queries. This is done by issuing detector messages by peers, to a small region so that receivers of the detector can record relative delay information and cut inefficient or redundant logical links as well as add closer nodes as direct neighbours. Three operations are defined in LTMband are furtherly discussed in the following paragraphs.
%
%\paragraph*{TTL2-detector flooding}
%\emph{TTL2-detector} messages are designed based on the specification of the Gnutella protocol. Suppose that $d(i, S, v)$ denotes the TTL2-detector which has the message ID of $i$ with TTL value of $v$ and is initiated by $S$. In addition to Gnutella's unified 23-byte header, such a message has a body of two types:
%\begin{itemize}
%  \item short format $d(i, S, 1)$ if $S$ is a direct neighbour of the receiver
%  \item long format $d(i, S, 0)$ if $S$ is within a two-hop distance from the receiver
%\end{itemize}
%This way a peer can calculate link costs from within a one- or two-hop area around it and thus reach peers in $N(S)$ and $N^2(S)$ sets, respectively, in the paper's context. Each peer floods a TTL-detector periodically while it calculates link cost to another peer by receiving other peer's detector messages and checking:
%\begin{itemize}
%  \item the Source Timestamp field and its own clock upon time of receipt for one-hop messages
%  \item the Source Timestamp, TTL1 Timestamp and its own clock upon receipt for two-hop messages
%\end{itemize}
%Of course peer clocks must be synchronized in order to do such checking.
%
%\paragraph*{Low productive connection cutting}
%There are three cases for any peer $P$ who receives $d(i, S, v)$ multiple times:
%\begin{inparaenum}[\itshape i\upshape)]
%  \item $P$ receives both $d(i, S, 1)$ and $d(i, S, 0)$
%  \item $P$ receives multiple $d(i, S, 0)$s from different paths, and P randomly chooses to process one
%  \item $P$ receives one $d(i, S, 1)$ and multiple $d(i, S, 0)$s, and $P$ processes $d(i, S, 1)$ and one randomly selected $d(i, S, 0)$
%\end{inparaenum}
%If the link with the largest cost is found and is a direct neighbour then the connection is put in a will-cut list and stays there for a certain period of time. If it is not, then it is handled by other peers. After that period, connections are cut and recorded to $P$'s cut-list.
%
%\paragraph*{Source probing}
%For a peer $P\in(N^2(S) - N(S))$ who receives only one $d(i, S, 0)$, the cost of $PS$ is obtained (with list look-up or probing). Then $P$ compares it with the cost from each hop and if $PS$ has the largest cost, $P$ will not keep this connection, while otherwise the connection will be created.
%
%\paragraph{}
%Supposing $n$ is the number of peers, $c_n$ is the average number of neighbours and $c_e$ is the average cost of logical links, then in the flooding-based search the traffic incurred by one query from an arbitrary peer in a peer-to-peer network is $O(n)$. As observed in the Gnutella network \cite{sripanidkulchai_gnutella_2001}, each peer issues $0.3$ queries per minute in average, thus the per minute traffic incurred by the network with $n$ peers is $O(n^2)$. Because each $d(i, S, v)$ has a TTL of $2$ in each source peer, the traffic for one time LTM optimization in all peers is at most $2nc_n^2c_e$. If each peer uses LTM $k$ times per minute, the total traffic incurred is $2knc_n^2c_e$. Simulation shows the best value for $k$ is $2$ or $3$. So, the traffic overhead caused by LTM to the network is $O(n)$.
%
%TTLj-detectors, with $j > 2$, would detect and break cycles with more than 4 links. LTM though, does not use such detectors because detector-flood traffic would increase significantly, and cut links between two end-peers, could cause queries initiated by them to traverse a path much more expensive than the cost on the the cut link.
%
%\paragraph{}
%LTM disadvantages are
%\begin{inparaenum}[\itshape i\upshape)]
%  \item disagreement of measured delay due to unsynchronized clocks causes problems when deciding the cut positions, which can influence the network connectivity, and
%  \item the network delay metric mainly focuses on disabling the connections between peers physically far away without considering the shortcuts created by powerful peers.
%\end{inparaenum}
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/ltm_multid.jpeg}
%\caption{Peer $P$ receives $d(i, S, v)$ multiple times}
%\label{figure:ltm_multid}
%\end{figure}
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/ltm_example.jpeg}
%\caption{A full example of LTM}
%\label{figure:ltm_example}
%\end{figure}
%
%\subsection{Scalable Bipartite Overlay}
%\emph{Scalable Bipartite Overlay (SBO)} \cite{liu_bipartite_2007} employs an efficient strategy to select query forwarding paths and logical neighbours. The topology construction and optimization of SBO consist of four phases:
%\begin{enumerate}[\itshape i\upshape)]
%  \item When a new peer is joining the network, it will randomly take an initial colour; say red or white. This colour is not to be changed for the time the peer stays connected. If it leaves and then rejoins it will, again, have to pick a colour, randomly. Thus all peers are separated into two groups, red or white. Then the bootstrap host will provide, the joining peer, with a list of active peers, including their colour information, in order for the later to establish connections to different colour peers. This way, all peers form a bipartite overlay.
%  \item White peers probe distances with their immediate (red) neighbours, form a cost table and send this table to their corresponding red neighbours.
%  \item Each red peer builds a minimum spanning tree using the obtained neighbour cost tables. These are two-hop diameter trees so white peers do not need to build one. The links that are part of a minimum spanning tree are called \emph{forwarding connections (FC)} while the rest \emph{non-forwarding (NFC)}.
%  \item Having a minimum spanning tree with two hops a red peer is able to send its queries within that range. Some white peers, though, have become non-forwarding neighbours. In this phase, such a (white) neighbour will try to find another red peer being two hops away from its current red neighbour to replace the later as its new neighbour.
%\end{enumerate}
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/sbo_efficient_forward.jpeg}
%\caption{A red peer $P$ has a small overlay topology of $N(P)$ and $N^2(P)$ and computes the efficient forwarding paths}
%\label{figure:sbo_efficient_forward}
%\end{figure}
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/sbo_neighbour_replace.jpeg}
%\caption{Neighbor replacement}
%\label{figure:sbo_neighbour_replace}
%\end{figure}
%
%In a static enviromnent LTM may reduce traffic cost by around 80 to 85 percent while SBO reduces traffic cost between 85 and 90 percent. However, LTM  is proved to converge in around 2-3 steps while SBO needs 4-5 steps. Moreover LTM reduces response time by more than 60 percent in 3 steps while SBO needs 8. In a dynamic environment (10 minute average peer lifetime, 0.3 queries/sec by each peer) SBO and LTM reduce the average traffic cost per query (including the overhead due to the optimization steps) by 85 and 80 percent, respectively. Moreover LTM reduces the response time per query to 30 percent while SBO to 35 percent.
%
%\subsection{Adaptive Connection Establishment}
%
%\paragraph{}
%\emph{Adaptive Connection Establishment (ACE)} \cite{liu_ace_2004} builds an overlay multicast tree among each source node and the peers within a certain diameter from the source peer and optimizes the neighbour connections that are not in that tree.
%
%\paragraph{}
%ACE indicates three phases for its algorithm:
%\begin{enumerate}[\itshape i\upshape)]
%  \item Calculate cost between nodes using network delay as a metric. Each peer probes the costs with its immediate logical neighbours and forms a \emph{neighbour cost table (NCT)} using a special routing message type. Two neighbouring peers exchange their NCTs in order for every peer to obtain the cost between any pair of its local neighbours forming a small overlay topology.
%  \item Based on obtained NCTs a minimum spanning tree among each peer and its immediate neighbours is built (Figure~\ref{figure:ace_phase2}).
%  \item Physically far away neighbours are replaced by physically close neighbours. In ACE a peer, say $S$, probes the distance between one of its non-flooding neighbour's neighbour, say $G$ and $H$ respectively. If the link to neighbour's neighbour is smaller than that to the neighbour, the later is cut. If this is not the case but $S$ finds that cost of $GH$ is even larger than that of the $SH$, $S$ will keep $H$ as a new neighbour. Obviously, if $SH$ is larger than $SG$ and $GH$, the connection will not be established and $S$ will continue probing another neighbour's neighbour. The algorithm described is conducted within $1$-neighbour closure (among its source peer and all its direct neighbours) but the optimization scope can be enlarged. The larger the scope, the better topology matching improvement but also the greater the computational overhead (Figure~\ref{figure:ace_phase3}).
%\end{enumerate}
%
%\paragraph{}
%Simulations in \cite{liu_acesims_2004} show that the average scope of each query to cover the same scope of nodes is reduced by about 65 percent without losing any autonomy feature, while the average response time can be reduced by 35 percent. Larger diameter topologies lead to better topology optimization rate but also to higher communication and computation overhead. It was also found that it is more effective in higher connectivity dense topologies. Compared to LTM, it comes short of convergence speed. In \cite{ni_mismatch_2004} shows reduction of both total traffic (90 percent) and response time (80 percent) to message queries without shrinking the search scope. SBO, on the other hand, achieves approximately 85 percent reduction on traffic cost and about 60 percent reduction on query response time. Last but not least, it is concluded that work must be done on incorporating a more sophisticated selection policy for candidate non-flooding peers.
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/ace_phase2.jpeg}
%\caption{Second phase in ACE}
%\label{figure:ace_phase2}
%\end{figure}
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/ace_phase3.jpeg}
%\caption{Third phase in ACE}
%\label{figure:ace_phase3}
%\end{figure}
%
%\subsection{Hops Adaptive Neighbour Discovery}
%
%\paragraph{}
%Paper \cite{chen_hand_2006} proposes a new algorithm named \emph{Hops Adaptive Neighbour Discovery (HAND)} which uses a fully distributed triple hop adjustment strategy to address the topology mismatch problem. The advantages of the algorithm compared to other approaches are that
%\begin{inparaenum}[\itshape i\upshape)]
%  \item it does not need any clock synchronization,
%  \item it is a fully distributed algorithm making it robust and reliable in decentralized systems,
%  \item the traffic overhead of the triple hop adjustment is very low,
%  \item it is applicable to dynamic peer-to-peer environments, and
%  \item maintains lower query response time.
%\end{inparaenum}
%
%\paragraph{}
%The algorithm's ultimate goal is the optimal overlay, the \emph{Logical Communication Network (LCN)} in the paper's context. The key concept of the algorithm is that a graph $G^{*}$ that describes an LCN and a graph $G$ that describes the current overlay are matched only if all peer hop sequences $(v_1, v_2, \ldots, v_k)$ in $G$ exist in $G^{*}$ and in the same order. In practice triple sequences $(v_1, v_2, v_3)$ are used.
%
%\paragraph{}
%The mismatching detection is done in the following way. Suppose we want to verify peer sequence $v_2-v_1-v_3$ (see Figure~\ref{figure:hand_com_overlay}). A pair of probing messages are sent from $v_1$ to $v_2$ and $v_3$. Suppose delays of $(v_1,v_2)$ and $(v_1,v_3)$ are are denoted as $x$ and $z$, respectively. When the probing message arrives to $v_2$ it forwards it directly to $v_3$. Similarly, when the probing message arrives to $v_3$, it forwards it directly to $v_2$. These last steps are performed in order to obtain delays of $(v_2,v_3)$ and $(v_3,v_2)$ physical paths, respectively, denoted by $y$.
%\begin{itemize}
%  \item If $y=z-x\pm\varepsilon$, sequence $v_2-v_1-v_3$ is mismatched and should be adjusted to $v_1-v_2-v_3$ by deleting edge $(v_1,v_3)$ and adding a new $(v_2,v_3)$ (see Figure~\ref{figure:hand_matchtriple_lemma3}).
%  \item if $y=x-z\pm\varepsilon$, sequence $v_2-v_1-v_3$ is mismatched and should be adjusted to $v_1-v_3-v_2$ by deleting edge $(v_1,v_2)$ and adding a new $(v_3,v_2)$ (see Figure~\ref{figure:hand_matchtriple_lemma4}).
%\end{itemize}
%$\varepsilon$ is a small positive real number denoting additional delays caused by possible forwarding and jitter delays.
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/hand_com_overlay.jpeg}
%\caption{The communication in overlay}
%\label{figure:hand_com_overlay}
%\end{figure}
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/hand_matchtriple_lemma3.jpeg}
%\caption{The matching triple in paper's Lemma 3}
%\label{figure:hand_matchtriple_lemma3}
%\end{figure}
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/hand_matchtriple_lemma4.jpeg}
%\caption{The matching triple in paper's Lemma 4}
%\label{figure:hand_matchtriple_lemma4}
%\end{figure}
%
%\paragraph{}
%Measurements conducted for evaluation perposes showed that in a static environment the algorithm can effectively decrease traffic cost by about 77 percent and shorten the query response time by about 49 percent in less than two minutes. In a dynamic environment it shows similar behaviour and with the size of the overlay network having little impact on the effectiveness of the algorithm. Compared to LTM both algorithms have almost the same traffic reduction rate, however on the response time reduction rate HAND has a higher one by about 4 percent. The traffic overhead of HAND is much less than that of LTM by an average of 55 percent.
%
%\subsection{Distributed Cycle Minimization Protocol}
%
%\paragraph{}
%\emph{Distributed Cycle Minimization Protocol (DCMP)} which is introduced in \cite{zhu_dcmp_2008} is a dynamic, fully decentralized protocol that promises significant reduction of duplicate messages. To achieve that, it uses the slightly different approach of eliminating unnecessary cycles, while retaining the connectivity of the network and preserving fault resilience and load balancing properties of unstructured peer-to-peer schemas by avoiding the creation of a hierarchical organization.
%
%DCMP aims at cutting the cycle paths at strategic locations. Any peer that detects a duplicate message can initiate the cutting process which consists of the following steps:
%\begin{enumerate}
%  \item Peers in the cycle elect a leader called \emph{GatePeer}\footnote{GatePeers are important for maintaining the connectivity and optimal structure of the network while peers join and leave randomly.}.
%  \item The cycle is cut at a well-defind point with respect to the GatePeer
%\end{enumerate}
%
%\paragraph{}
%The first step after detecting a duplicate message by some peer is to gather information from all peers in the cycle using a new type of control message called \emph{Information Collecting Message} or \emph{ICM}. ICM contains:
%\begin{inparaenum}[\itshape i\upshape)]
%  \item a \emph{GUID}\footnote{Globally Unique IDentifier assigned to every query message generated by any node.} field same as the one of the duplicate message,
%  \item \emph{DetectionID} field which represents the direction of the connection where the duplicate was identified\footnote{This ensures the uniqueness of the ICM messages because as it travels through many cyclic paths, multiple peers will detect the duplicates and initiate an ICM message.}, and
%  \item \emph{Node Information Vector (NIV)} which contains information (bandwidth, CPU power, etc) about peers that propagated the ICM.
%\end{inparaenum}
%
%\paragraph{}
%Suppose $A$ detected the duplicate as depicted in Figure~\ref{figure:dcmp}. It then emits an ICM to $B$ and $F$, that initially contains information only about itself. Each peer that receives the ICM, appends its information and propagates it along the reverse path of the original message. Since two copies of ICM are sent, at some point, a peer, say peer $D$, will receive a duplicate ICM. Using the information in the NIVs of the ICMs, $D$, decides to cut (for example) the EF connection. To inform the other peers about its decision, it emits a \emph{Cut Message (CM)} which contains the GUID and DetectionID of the corresponding ICM and an additional field that identifies the connection to be cut. $D$, then, forwards the CM in the reverse directions from where the ICM arrived. Similarly CMs received by any peer are propagated toward the reverse path of the corresponding ICM. Eventually, either peer $E$ or peer $F$ will receive the CM and cut the connection, thus eliminating the cycle.
%
%Receiving a duplicate ICM denotes the existence of a cycle. The opposite is not true though. For example, if the cycle contains $2 \times TTL$ edges, it will not be detected, because the ICM messages will be discarded before they locate it. There is a tradeoff between preserving the connectivity of the network and minimizing the duplicates that makes such a possibility to be safely ignored.
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/dcmp.jpeg}
%\caption{Cycle elimination methods in DCMP}
%\label{figure:dcmp}
%\end{figure}
%
%\paragraph{}
%Experiments in \cite{zhu_dcmp_2008} showed that DCMP incurs a lower delay, returns more results and decreases the number of duplicate messages by 22\%, compared to LTM. Additionally DCMP has one to two orders of magnitude less overhead, because it adopts a more ``LAZY'' approach than broadcasting control messages periodically like LTM does.
%
%\subsection{Two-Hop-Away Neighbour Comparison and Selection}
%
%\paragraph{}
%Work in \cite{liu_thancs_2005,liu_thancs_2008} proposes a distributed heuristic called \emph{Two-Hop-Away Neighbour Comparison and Selection (THANCS)} that
%\begin{inparaenum}[\itshape i\upshape)]
%  \item is completely distributed and needs no global knowledge,
%  \item presents trivial overhead compared to the query cost savings
%  \item its convergent speed of the algorithm is fast enough (faster than minimum spanning tree approaches) so that is effective to dynamic environments, and
%  \item does not shrink the search scope.
%\end{inparaenum}
%
%\paragraph{}
%THANCS is considered a \emph{local search method}, in the sense that it targets in finding a locally optimum solution, by exploiting knowledge within a 2-hop radius. The algorithm consists of two main components: \emph{piggybacking neighbour distance on queries} and \emph{neighbour comparison and selection} which are furtherly discussed bellow.
%
%\paragraph{Piggybacking neighbour distance on queries}
%Using network delay as a metric for measuring the distance, each peer probes distances with its immediate naighbours and stores information locally. For this reason a special query message type, \emph{Piggy Message (PM)}, is introduced. It is 6 bytes long and includes two fields: Neighbour IP Address and Neighbour Distance. A peer $P$ constructs a PM for its neighbour $Q$, which contains $Q$'s IP address and $Q$'s distance from $P$. When $P$ receives a query from $Q$, this PM will be piggybacked by the query that goes to all other neighbours of peer $P$. Upon receiving such a query message, each of the other neighbours will detach the PM, record the $PQ$ distance and process the query. This PM will not be further forwarded. In selecting which incoming queries  should piggyback a PM the paper proposes the \emph{pure propability-based (PPB)} and the \emph{new neighbour triggered (NNT)} policies.
%
%\paragraph{Neighbour comparison and selection}
%Figure~\ref{figure:thancs} illustrates this component of the THANCS algorithm. A peer $S$ probes the distance to all known unprobed $N^2(S)$\footnote{$N^2(S)$ denotes the set of peers being two hops away from $S$, while $N(S)$ denotes the set of direct logical neighbours of $S$.}. The distance of $SP$ is known to $S$. Upon receiving a PM from node $P$ with the distance of $PQ$, $S$ follows one of the following:
%\begin{itemize}
%  \item $Q \in \left( N(S) \cap N^2(S) \right)$, i.e. $Q$ is direct neighbour of $S$. In this case $S$ will compare cost of $SQ$, $SP$ and $PQ$. If the most costly connection is one of $SQ$ or $SP$ the corresponding link will be put into a \emph{will-cut list}\footnote{Links are not immediately disconnected when put in the will-cut list. There are useless for forwarding but are kept active, for some time, in order to serve query responses that are traveling to the source peer along the inverse search path.}. If the most costly connection is $PQ$ then $S$ will do nothing, as the fully distributed nature of the algorithm will give a chance to either $P$ or $Q$ to cut the connection.
%  \item $Q \in \left( N^2(S) - N(S) \right)$, i.e. $Q$ is a two-hop-away neighbour of $S$. If $S$ hasn't probed $Q$ before\footnote{A distance cache is maintained and looked up in such a case.}, it probes and stores the result in the \emph{distance cache}. Having the distance of $SQ$, $S$ compares costs of $SQ$, $SP$ and $PQ$. If $SQ$ is the most costly, $S$ will not establish the connection. If $SP$ is the most costly, $S$ will establish connection $SQ$ and put $SP$ in the will-cut list. If $PQ$ is the longest, $S$ will keep  the connection with both $P$ and $Q$, expecting that $P$ or $Q$ will eventually disconnect link $PQ$, later.
%\end{itemize}
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/thancs.jpeg}
%\caption{Probing two-hop-away neighbours}
%\label{figure:thancs}
%\end{figure}
%
%\paragraph{}
%In a static environment THANCS has been proven to be effective; optimizing 45 percent out of the 60 percent of mismatched paths, constructing a nearly optimal overlay. This leads to a 60 percent reduction in traffic cost as well as a 40 percent decrease in query response time. In dynamic environments (Gnutella 0.6/Limewire super-peer-like and Ion flat-like), THANCS saves up to 70 percent of the traffic cost in the super-peer topology and 55 percent for the flat one. Average response time is also decreased by 60 and 45 percent, respectively. Generally, THANCS has similar performance to LTM, without needing synchronization. SBO, incurring half the  overhead of AOTO, reduces the traffic cost the most, while THANCS has lower response time and converges faster than SBO. THANCS is, thus, more suitable for a more dynamic environment. In addition, THANCS is easy to implement and its operation overhead is trivial, compared with the other three approaches. This design, however, has the limitation of not being easily extend to also support non-flooding-based systems.
%
%\subsection{mOverlay}
%Zhang et al. in \cite{zhang_moverlay_2004} focus on two aspects of the overlay construction. First, to achieve \emph{efficiency} of communication, a protocol should minimize unecessary long-distance hops and redundant traffic. Second, to be \emph{scalable} the overlay should be constructed in a distributed fashion and maintenance cost (data and locality management) should be minimized. Both of the above observations, are positively affected by the exploitation of node proximity at the underlying network. To accomplish it, the paper introduces the \emph{group} concept, according to which non-static (dynamic) landmarks are used to compute proximity, resulting in a highly robust and scalable overlay construction with reduced maintenance cost as well. The dynamic nature of landmarks help towards load-balance, meaning that hot-spots are avoided.
%
%\paragraph{}
%The proposed architecture, called \emph{mOverlay}, is a \emph{clustering approach} which creates a two-level hierarchical network, where on the top level we have connections between groups while on the bottom we have connections between hosts inside groups, thus attempting to recreate \emph{Small-World}-like properties for the constructed overlay network. The notion of a \emph{group}, in the paper's context, is a set of hosts that are close to each other with respect to any position $P$ in the underlying network. The distance between hosts can be 
%\begin{inparaenum}[\itshape i\upshape)]
%  \item network latency,
%  \item round-trip time,
%  \item minimum bandwidth on the links along the path connecting the two nodes, or
%  \item some other user-defined cost metric between the two nodes.
%\end{inparaenum}
%These nodes are refered to as neighbouring. Similarly groups can exchange messages with their neighbouring ones\footnote{Groups nearby, in the underlying physical network.}.
%
%According to the \emph{grouping criterion} set by the authors, a new host $Q$ belongs to some group $A$ if the distance between $Q$ and group $A$'s neighboring groups is the same as the distance between group $A$ and it's neighbouring groups. The neighbour groups thus, play the role of the dynamic landmarks and for accuracy and performance reasons the nearest of them are chosen to play that role.
%
%\paragraph{Locating process} A new coming host, $Q$, first connects to a globally known host cache called the \emph{rendezvous point (RP)} in order to retrieve the starting point in the overlay, say $A$ in group $1$. Host $Q$ then, measures its distance to host $A$. At the same time, the later, sends information about the neighbour groups of group $1$ back to host $Q$. This list is called \emph{candidate group list}, and the newcoming host sequnentially measures its distance to each of them in seek for the closest one. If the \emph{grouping criterion} is met, host $Q$ belongs to group $1$. If not, a boot host from the closest group is found and the algorithm is re-run until the criterion is met or after a predefined number of repetitions. In the later case, $Q$ creates a new group comprising itself only. The above protocol does not favour hotspots as it spreads the probability of visiting a group across the whole overlay and limits the overhead in the level of $O \left ( log N \right )$.
%
%\paragraph{General overlay operations} A set of additional protocols, are also introduced, similar to those found in traditional unstructred networks, but modified focusing on scalability and robustness. For example a protocol for \emph{group formation} is introduced that exploits the inherent characteristic of proximity, in the overlay, in order to efficiently detect the neighbouring groups of a newly formated group from the set of adjasent groups of its closest neighbour. Additionaly, during \emph{group joining} the coresponding protocol denotes the exchange of important information for group maintenance. This can be furtherly improved by \emph{information sharing} between nodes of the same group, functionality handled by a dedicated flood-like protocol\footnote{Since nodes that belong to the same group are physically close this can be achieved at a minimum price.}. Moreover, another set of distributed protocols handle the \emph{information update}. The information that needs update, in the proposed architecture, is
%\begin{inparaenum}[\itshape i\upshape)]
%  \item the host cache, when a new node joins, and
%  \item the neighbours of groups, when a close-by group is generated.
%\end{inparaenum}
%Finally, in case of \emph{host failure} or \emph{host departure} the system is able to maintain its stability since there are defined operations for periodical host cache update and group leader selection if one leaves or dies.
%
%\subsection{Distributed Domain Name Order}
%{\sethlcolor{yellow}\hl{HA:  In paper/introduction nice advantages of unstructured networks:
%
%Unstructured P2P networks o?er a number of
%important advantages: (i) An unstructured network
%imposes very small demands on individual nodes,
%and more speci?cally it allows nodes to join or leave
%the network without signi?cantly a?ecting the sys-
%tem performance. (ii) Unstructured networks are
%appropriate for content-based retrieval (e.g., key-
%word searches) as opposed to object identi?er loca-
%tion of structured overlays. (iii) Finally unstructured
%networks can easily accommodate nodes of vary-
%ing power. Consequently, they scale to very large
%sizes and they o?er more robust performance in
%the presence of node failures and connection
%unreliability.
%}}
%
%\paragraph{}
%\cite{z-yk_ddno_2005} proposes the \emph{Distributed Domain Name Order (DDNO)} technique which makes unstructured overlay networks, topologically aware. It results in a flat overlay topology but with some changes it can be utilized in \emph{superpeer} environments. In DDNO, a node of degree $d$, tries to connect to $\frac{d}{2}$ nodes that belong to the same domain (\emph{sibling} connections) and another $\frac{d}{2}$ of random nodes (\emph{random} connections). Connecting to \emph{sibling} nodes ensures the reduction of long distance message travelling and thus resulting to better performance, while \emph{random} nodes keep the structure connected.
%
%\paragraph{Discovering \emph{random} neighbours}
%Initially, when a new coming node wants to join a network $N$, uses a \emph{hostcache} mechanism to provide it with a list of nodes with which to establish its $\frac{d}{2}$ \emph{random} connections.
%
%\paragraph{Discovering \emph{sibling} neighbours}
%In order to discover the rest $\frac{d}{2}$, \emph{sibling}, nodes, the \emph{lookupDN} procedure is initiated. In this phase, a special $l$ walker message is multicasted, by the newcomer, in search of a node that knows\footnote{A special structure is used called ZoneCache that contains information about which nodes are reachable in an $r$-hop radius.} how to guide $n$ to a \emph{sibling} node.
%
%\paragraph{}
%Figure~\ref{figure:ddno_lookupdn} shows an $l$ message emitted by node $n$ which travels along the path [$a$, $b$, $c$, $e$, $b$, $d$]. At node $d$, $l$ finds information to make a decision on which neighbour to follow next\footnote{Contrary to the random choices, made at the previous hops.}. Ultimately $l$ arrives at $m$, which is a \emph{sibling} node to $n$. $m$ then issues a broadcast message to all its own \emph{siblings}. Each of the receiving nodes, $m$ included, will respond to $n$ with a designated $l^{'}$ message if it is willing to accept new connections and out of these answers, node $n$, will attempt to establish its, remaining, $\frac{d}{2}$ \emph{sibling} connections.
%
%\paragraph{}
%Unfortunately, use of DDNO results in networks which have a uniform distribution of node degrees, losing the valuable properties of Power Law and Small World networks, as mentioned previously in this survey.
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.375]{img/ddno_lookupdn.jpeg}
%\caption{Domain name look-up in a \emph{DDNO} topology}
%\label{figure:ddno_lookupdn}
%\end{figure}
%
%%\subsection{Critical Topology-Aware Grouping}
%%
%%\paragraph{}
%%\emph{Critical Topology-Aware Grouping (CTAG)} presented in \cite{zhao_ctag_2006}, is a grouping algorithm that tries to exploit low-cost and low-delay communication of physically close-by peers. The grouping strategy is based on the \emph{IANA}\footnote{Internet Assigned Numbers Authority} and the respective \emph{Regionanal Internet Registry (RIR)}'s IP assignment strategies, according to which nodes within the same organization are always addressed from the same block. The paper proposes the \emph{Adjacency Measurement (AM)} technique which uses the longest matching IP segment criterion to calculate node proximity.
%%
%%Observations made in various studies (e.g. \cite{matei_mapgnutella_2002}) concerning the distribution of nodes among \emph{Internet Service Providers (ISPs)} and \emph{Autonomous Systems (ASs)} have shown that only $2$ to $5$ percent of Gnutella connections link peers within a single AS while more than $40$ percent of all Gnutella peers are located within the top 10 ASs. Similarly, measurements in \cite{zeinalipour-yazti_gnudc_2002} used a $244,000$ IPs test-bed and results have shown that $45$ percent of the nodes belonged to only $10$ large ISPs and $58$ percent belong to only $20$. Such results mean that most overlay generated traffic crosses AS borders increasing topology mismatch cost.
%%
%%\emph{CTAG} focuses on both the construction of the overlay as well as dynamically revising it during node interaction, phases called \emph{bootstrapping grouping} and \emph{dynamic revision}, respectively in the paper's context.
%%
%%\paragraph{Bootstrapping grouping}
%%The \emph{Gnutella Web Caching} mechanism has been modified in order for a new coming node to choose the closest \emph{GWC} in order to retrieve the node list for bootstrapping.
%%
%%\paragraph{Dynamic revision}
%%Similarly to the bootstrapping phase, \emph{AM} metric is used to store hosts' addresses. read from \emph{X-Try} headers during handshake or from \emph{QueryHit} messages. Additionally, when a node reaches the max neighbour connections, node disconnects the neighbours with the lowest \emph{AM}.
%
%\subsection{Peer-exchange Routing Optimization Protocols}
%
%\paragraph{}
%Work presented in \cite{qiu_prop_2007} introduces \emph{peer-exchange}\footnote{A series of exchanges of neighbours between two peers. One exchange can be viewed as a pair of cut-add operations.} as a basic operation to adaptively adjust the connections of the overlay network, and efficiently reduce the average logical link latency of the whole system. There are two points that differentiate this scheme from others:
%\begin{inparaenum}[\itshape i\upshape)]
%  \item it utilizes the collaboration of two peers to optimize their neighbourhood environment, than simply letting each node to ``selfishly'' choose its own strategy, and
%  \item can be deployed effortlessly on both unstructured and structured peer-to-peer systems.
%\end{inparaenum}
%
%\emph{PROP-G}\footnote{\emph{G} stands for \emph{generic}.} is the simple and direct variant of \emph{peer-exchange} in which two neighbours swap all their neighbours. As depicted in figure~\ref{figure:prop-g} the mechanism can be viewed as, nodes, exchanging overlay ``positions''. Thus, the overall overlay topology is not affected by the this operation.
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/prop-g.jpeg}
%\caption{PROP-G in which a neighbours are exchanged.}
%\label{figure:prop-g}
%\end{figure}
%
%The alternative protocol proposed, called \emph{PROP-O}\footnote{\emph{O} stands for optimized}, ensures that the degree of each participating node remains the same by selectively choose the same number of neighbours for the exchange. With this mechanism, 2 nodes exchange the same number of neighbours in order not to change the degree
%
%\begin{figure}
%\centering
%  \includegraphics[scale=0.4]{img/prop-o.jpeg}
%\caption{PROP-O exchanging \emph{m} neighbours.}
%\label{figure:prop-o}
%\end{figure}
%
%\subsection{T2MC}
%
%\paragraph{}
%\emph{T2MC}\cite{shi_t2mc_2008} exploits some properties of the Internet paradigm and clusters nodes belonging to the same ISP without any centralised control or predefined system parameterization. The algorithm considers the dynamic nature of peers and exploits the stable nature of routers in order to build a topology location relationship among end peers.
%
%\paragraph{}
%Some special routers split the physical network into autonomous system domains. Using a Traceroute mechanism T2MC searches for latency leaps among the path to a host in order to form ``near'' and ``remote'' router clusters. This is achieved by a 2-Means Classification, defined by the following steps:
%\begin{enumerate}
% \item the peer chooses the minimum and maximum Latency results from the Traceroute for initializing the cntroinds of two sets ``first'' and ``second''.
% \item The peer calculates, for all hops allong its tracerouted path, the absolute distance to the centroids of both sets and assigns the routers to that centroid with which it has the smaller absolute distance.
% \item The peer calculates the latncy mean and variance value of two sets
% \item If the variance is larger than a predefined threshold then the algorithm takes a loop from step 2 picking the two latency mean values as new centroids of sets ``first'' and ``second''.
%\end{enumerate}
%Ultimately peer will end up with two sets having the minimum intra-set variance. Finally the peer chooses the router from ``second'' set with the minimum hops attribute and sets it as a threshold. The selected router and all others whose hops attribute is larger than the threshold are classified as ``remote'' router cluster. The remaining are classified as ``near''. From the ``near'' class, the peer chooses the one with maximum hops attribute as its edge router, and registers it along with the all the ``near'' cluster into the DHT of the p2p overlay. As new peers join the network, those that share the same edge router or any of the members of the ``near'' router clustersm ther would gather to form a ``close'' peer cluster. As Edge routers can provide more valuable information than other members of the ``near'' set, T2MC was designed to prioritize interaction of peers and edge gateways.
%
%% TODO: figure t2mc.jpeg (a) stars represent edge routers (b) hop leaps
%
%\paragraph{}
%The use of Traceroute as a tool for implementing the distance measuring infrastructure raise concearns about its efficiency and scalability. Being, primarilly, a network diagnostic utility, it is concearned too heavy weighted and intrucive for use in a larger scale\cite{ratnasamy_binning_2002}. Additionally, disabling ICMP is a common administrative policy for edge sites to enforce security, while dumping BGP routing tables\cite{krishnamurthy_bgpclust_2000} is not directly available to the application layer.
%
%\subsection{Unnamed Unstructured!!}
%% TODO: to be reviewed
%
%\paragraph{}
%In \cite{hsiao_redblue_2009}, Hsiao et al, claim to construct topology-aware unstructured overlays that \emph{guarantee} performance qualities in terms of
%\begin{inparaenum}[\itshape i\upshape)]
%  \item the expected communication latency among any two overlay peers regardless of the network size, and
%  \item the broadcasting scope of each participating peer.
%\end{inparaenum}
%
%The algorithm constructs an undirected graph $G = \left( V, E \right)$ comprised by two subgraphs. The first, namely $G^{\left( red \right)} = \left( V^{\left( red \right)}, E^{\left( red \right)} \right)$ in the paper's context, includes all vertices of $G$ and ensures the connectivity of the graph by securing at least one path between any two nodes. In contrast, $G^{\left( blue \right)} = \left( V^{\left( blue \right)}, E^{\left( blue \right)} \right)$, contains those vertices of $G$ that have free edges to link to other nodes and because these are fully utilized, the following also stands $E = E^{\left( red \right)} \cup E^{\left( blue \right)}$.
%
%A joining peer $u$, partitions its neighbours into two subsets, the $B_u^{\left( red \right)}$ and $B_u^{\left( blue \right)}$. In order to populate the $B_u^{\left( red \right)}$ subset, peer $u$ samples peers uniformly and at random. Then, each of these selected peers discovers a routing path starting from itself towards the node with the smallest (or the largest) ID in the system.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STRUCTURED
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsection{Landmark Binning}
%The scheme proposed in \cite{ratnasamy_binning_2002} is based on the process of \emph{binning} close by nodes (in terms of network latency) into the same cluster. The authors set the following objectives for designing their proposed algorithm:
%\begin{enumerate}
% \item simplicity (minimal support from any measuring infrastructure),
% \item scalablility (no global knowledge of the network),
% \item complete distribution (nodes need no communication-cooperation).
%\end{enumerate}
%
%\paragraph{Binning scheme}
%The implementation requires a set of well-known \emph{landmark} machines spread accross the Internet. Every newly arriving node measures its distance from these landmarks and unilaterally decides to join a specific bin based on these results. In more detail the node measures its round-trip time to each of the landmarks and orders these measurements in a decreasing order. The ordering represents a ``bin'', in the sence of close-by nodes having the same landmark ordering and hance belong to the same ``bin''. This means that a landmark system consisting of $m$ such nodes results in $m!$ potentional different bins.
%
%The algorithm can be considered scalable, as nodes need only compute distances to a small number of predefined nodes and thus without exchanging any information. A potential bottleneck could be the extra load that this ``ping''-like scheme imposes to the landmarks, especially when we need instant reaction from our topology when dealing with the dynamic nature of the p2p networks.
%
%To answer the question as to whether the algorithm actually contributes possitivelly to the construction of an enhaned overlay, the paper defines the \emph{gain ratio} as the factor by which the latency reduces when someone communicates with a random node from the same bin than with one not in the bin. This is implemented with an inter-bin to an intra-bin latency ratio.
%
%\paragraph{Structured and Unstructured Binning}
%The \emph{binning} scheme can be incorporated within either a structured or an unstructured overlay construction algorithm. The authors provide an example for both these cases.
%
%\paragraph{}
%Assuming a structured approach based on CAN\cite{ratnasamy_can_2001} and $m$ landmark nodes. The coordinate space is then partitioned into $m!$ equally sized portions, each corresonding to a single ordering of the landmarks. To do this, the first dimension is divided into $m$ areas each of which is furtherly divided (second dimension) into $m - 1$ sections and so on. Having set this $m$ dimensional space, at joining time, a node measures the delay to the set of landmarks in order to determine its associated bin and thus position itself in that portion of the coordinate space associated with its landmark ordering. Even though this scheme can 
%
%For unstructured overlays the paper assumes \emph{a set of $n$ nodes where each node picks any $k$ neighbour nodes so that the average routing latency on the resultant overlay is low (assuming shortest path routing)}. According to the proposed heuristic algorithm called \emph{BinShort-Long}, a node picks its neighbours by choosing its $\frac{k}{2}$ closest\footnote{If the node's bin is not large enough for it to pick these $\frac{k}{2}$ neighbours, it picks the required nodes from the bin that matches the most in terms of landmark ordering.} ones (named \emph{short links}), using the \emph{binning} scheme and the rest $\frac{k}{2}$ randomly (\emph{long links}). The former set produces well-connected \emph{pockets} of nearby nodes while the later preserves the connectivity of the graph, both yielding a proximity factor of $\alpha = 0.5$ in an attempt to preserve the benefitial properties of unstructured topologies\cite{merugu_str2unstr_2003}.
%
%\paragraph{}
%% TODO double check validity
%One disadvantage of this landmark scheme is related to the additional burden imposed to the landmark sites. The authors claim though that the algorithm requires so little work by the landmarks (maybe just echo to ping messages) that could in effect, act as ``unsuspecting participants''. Even if this is the case, the fact that it is not fully distributed, renders the protocol's scalability directly volnerable to any system size increase as well as usuitable for highly dynamic networks such as ad-hoc networks. Moreover, fixed points in a network are inherently more exposed to malicius attacks. The most significant downside of the algorithm though is that it can lead to an extremely uneven overlay ID distribution causing load inbalances and hot spots. Lastly, the scheme is coarse grained when it comes to distinguishing relatively close nodes\footnote{In the worst case, all nodes could ve clustered into a single bin.}.
%
%\subsection{Global Soft-State}
%{\sethlcolor{yellow}\hl{HA: in paper introduction, discussion about
%disadvantages of top-aware CAN:
%
%Techniques to exploit topology information in overlay
%routing include geographic layout, proximity routing and
%proximity neighbor selection [3]. With geographic layout
%such as topology-aware CAN [12], the overlay structure is
%constrained by underlying network topology. This tech-
%nique, unfortunately, can create uneven distribution of
%nodes in the overlay, increasing the chances of overloading
%nodes and rendering the maintenance cost formidable. Our
%study shows that, for a typical 10,000-node topology-aware
%CAN, 5% nodes occupy 85-98% of the entire Cartesian
%space, and some nodes have to maintain 450-1500 neigh-
%bors. In Proximity routing, physical topology is not consid-
%ered when constructing the overlay.
%
%[snip]
%Studies [14] have shown that triangle inequal-
%ity may not hold in Internet topology. In fact, study from
%Pastry has shown that the proximity approximation is much
%worse when using the Mercator topology that is based on
%the real measurements of the Internet [3].
%
%RELATED WORK:
%
%Miguel Castro et al [3] divide techniques used to
%exploit network proximity into three categories: geographic
%layout, proximity routing and proximity neighbor selection.
%Proximity neighbor selection is superior in terms of load
%balancing and proximity approximation. The existing algo-
%
%}}
%
%\paragraph{}
%The approach argued by Xu et.al in \cite{xu_globstate_2003} is to build a global map to help choose shorter routing paths, combining the landmark binning method and small scale distance probes to reveal the proximity properties of the underlying network to the overlay. This global view of the state is made available to all nodes in order to help them find the best way to route their messages. The authors focus on two aspects in order to accomplish their goal.
%
%\paragraph{}
%Initially, is the \emph{generation} of proximity information and then its \emph{effective exploitation}. For the first, a hybrid approach is proposed, which uses landmark clustering as a preprossesing step in order to select a number of potential nearest neighbour candidates and then refine the selection by incorporating an RTT scheme to ultimately choose the closest node. For the second, the algorithm chooses a different path from the classic gossiping approaches for constructing and maintaining the overlay. It is based on landmark-clustering-based strategic placement of proximity information on the overlay enabling any node to access such information using a landmark number that reflects its physical position in the network. For various logical regions\footnote{This might be a high-order zone in the eCAN\cite{xu_ecan_2002} context or a set of nodes sharing a particular prefix in overlays such as Pastry.} maps of physical information are built and published where each node may appear in a maximum of $log\left( N \right)$ such maps.. To dynamicaly adapt to changing network conditions, a node subscribes to relevant \emph{soft states} that utilize a notification system in order to initialize any necessary neighbour re-selection.
%
%\paragraph{}
%Maintaining several host states at different layers, makes any content migration costly. Additionaly, the method does not make any continuing effort to remap the overlay structure after a node successfuly joins, in order to adapt its state to any occurance of condition change. Although this approach greatly reduces the routin latency to far nodes, it is unable to dynamicaly identify nodes that are close to routers and gatways in order to construct the secondary overlay. Nevertheless, static recognition of such nodes is currently done based on BGP reports and prechosen landmarks, sucrificing the self-organising attribute of traditional DHTs.
%
%\subsection{Self-Adaptive Topology Matching}
%
%\paragraph{}
%Ren et.all's goal while designing the \emph{SAT-Match} algorithm \cite{ren_satmatch_2004} was to create a protocol that would be decentralised and scalable, fine-grained in detecting changes and adaptively reform in response to the dynamic nature of a classic p2p environment and last, but certainly not least, of low incuring cost. The method is in a nutshell, a two-phased iterative process that focuses on local optimizations in order to collectively achieve a global full overlay optimization.  The iteration is finised when the node detects that it is physicaly close enough to its neigbours so that no additional optimization is needed. The paper defines \emph{stretch}, $S = \frac{\bar{L_l}}{\bar{L_p}}$, as a way quantify the \emph{topology match degree} of the constructed overlay, where $\bar{L_l}$ is the average logical link latency while the $\bar{L_p}$ is the average physical link latency.
%
%\paragraph{Probing phase}
%\emph{SAT-Match} uses a small TTL value for the probing messages in order to reduce redunduncy\cite{jiang_lightflood_2008}. This process begins as soon as the node joins the network using a DHT mechanism. Each probing message contains information about the source and a small TTL value. The recipient of such a message returns information about itself to the source and forwards the probing message to its neighbours if the TTL is non-zero. The nodes been covered, are refered to as $TTL-k$ neighbourhood of the source node\footnote{Especialy, $TTL-1$ neighbourhood referes to the source's direct neighbours}. The list of responses is used to measure RTT to these nodes and sort the list ascending RTT order.
%
%\paragraph{Jump phase}
%Blindly selecting the peer with the smallest RTT as neighbour is, generally, not the right desision to make in order to achieve global \emph{stretch} reduction, This is because, in a structured scheme, when a node jumps to connect to a physically close node, it may need to connect to other distant nodes to maintain the structure's integrity, thus creating an overall increase in the overlay's \emph{stretch}. The two nodes with the smallest RTT is then used in order to select one zone to jump in this phase. The algorithm is as follows: The source node $S$ calculates the stretch change of its $TTL-1$ neighbourhood and that of the $TTL-1$ neighbourhood of the first of the previously selected peers. These calculations are made as if the jump has been made. If the stretch reduction is over a predefined threshold the jump is performed, otherwise the second selected candidate is picked and the same computations are performed. If again, the threshold is not met, then no jump is ultimately done. In case of a jump, this is performed as a combination of \emph{leave} and \emph{join} operations, in the CAN context.
%
%\paragraph{}
%Moreover the algorithm takes several issues into consiteration in order to furtherly improve the resulted overlay. For example when multiple nodes try to jump simultaneously into a regeon, then the logical link brakes from one attempt may result in inacurate computation of the gain factor, for an other. This situation is identified as \emph{contention} and the nodes use an exponatial back-off algorithm to avoid it. An other problem is the uneseccary traffic incuerred by the probing phase in a region that after several jumps has settled to a stable state. In these cases it is more likely for jump attempts to be proven worthless. The algorithm doubles the probing period of such nodes, every time a jump is not taken.
%
%\paragraph{}
%The authors claim that this continuously adaptive mechanism achieves global topology matching optimization in a sufficiently large scope. This also secures the fast adaptation to frequent network changes. It also considered lightweight and can easily be embedded into current p2p systems, as well as effectively combined with other techniques, such as landmark binning.
%
%\subsection{Delay Aware P2P System}
%A new \emph{Delay Aware P2P System (DAPS)} is introduced in \cite{zhang_daps_2005}. Its main goal is to reduce the time $L$ of a look-up request by dividing the routing tables of peers into several sectors in increasing delay. The source node emitting the query message defines a delay boundary or the pruning factor $L_t$ in the paper's context. Request messages will be forwarded only to nodes whose delay less than or equal to $L_t$. With the clustered routing tables and the loose organisation the overlay network of \emph{DAPS} is between structured and unstructured.
%
%\subsection{Mithos}
%
%\paragraph{}
%Waldvogel and Rinaldi proposed a protocol\cite{waldvogel_mythos_2003} which incorporates a directed incremental probing to find near optimal node placement.
%
%\paragraph{Neighbour detection}
%During bootstraping, the new comming node needs to know how to contact at least one of the existing members. A subset of these nodes will be used as the first set of candidate neighbours. Then, iteratively, each of the peers in the cadidate set is asked for their neighbours in order for each of the later to be probed for their network distance from the new coming one. The closest node is then used as the new candidate neighbour and the process is repeated until no further improvement is detected. Due to the fact that the algorithm may ultimately reach a local minima instead of a global one, \emph{Mithos}' approach is to first probe all neighbours within a two hop distance from the current minimum before concluding the process.
%
%\paragraph{ID assignment}
%After finding its first neighbour, the newcoming peer must be assigned its ID, a very crusial selection in order not to create many local minima that will prevent efficient future neighbourhood location. \emph{Mithos} uses information gathered during the previous step, in order to compute the ID, which inccurs no further communication costs to the algorithm. This information includes
%\begin{inparaenum}[\itshape i\upshape)]
%  \item the two closest nodes and their neigbours, and 
%  \item their coresponding distances.
%\end{inparaenum}
%Using the above, it then assigns coordinates to the new-coming node, so that Euclidian distances between the node and all known hosts predict the network latency between them\cite{cox_vivaldi_2004}. These synthetic coordinates as explicitly used as the node's ID and as soon as it has been established, distances can be computed in the ID space, no longer requiring physical measurements.
%
%\paragraph{Link establishement}
%The last step of the algorithm is the interconnection among neighbours. \emph{Mithos} uses a \emph{quadrant}-based mechanism according to which each node establishes a link to the closest neighbour in each quadrant. During forwarding, the next hop is performed towards a neighbour in the same quadrant as the final destination\footnote{An implementation of this could be backed by a $d$-bit vector indexing (where $d$ is the number of dimensions) into the routing table. Then the next hop is identified by computing the difference between the current node's vector and that of the destination's.}. The problem is that after the ID assignment process, the new-coming node may not know of other neighbours in all quadrant and if even if it does, this cannot ensure that they are the nearest available. Thus, the node first identifies neighbours in all quadrants using a mechanism based on ideas similar to a perimeter walk\footnote{Used in Greedy Perimeter Stateless Routing (GPSR) protocol.} and then using parallel path processing improves the results by taking into account further geometric properties of node relationships.
%
%\paragraph{}
%% TODO review this part
%In order to avoid local minima during neighbour detection, extensive probing must be undertaken. In simulation, unfortunately, only very small-sized overlay topologies (of 200 to 1000 nodes) have been used and thus no safe conclusions can be made as for the behaviour of an extensively large, real-world p2p deployment of the scheme. 
%
%\subsection{DHT-PNS}
%
%\paragraph{}
%The work in \cite{hancong_pnsbased_2006} propose a proximity neighbour selection scheme on top of the Chord DHT. Using the Vivaldi protocol\cite{cox_vivaldi_2004} each node is assigned synthetic $2$-dimension coordinates that can be used to derive network latency using Euclidian distances in the id space and without the need of explicit probing. Then the algorithm performs the two steps described in the following paragraphs.
%
%\paragraph{Space mapping}
%The space is partitioned using a \emph{concentric circle clustering scheme} where succesive cycles of radiuses $\rho$, $2\rho$, $3\rho$ and so on, are constructed. Then the formed annuluses are divided into $2\chi-1$ \emph{sectors}, where $\chi$ denots the sequence number of the annulus starting from $\chi = 1$ for the centre cycle. It is proved in the paper, that this way each sector occupies the same area\footnote{The same area as does the center cycle.} and assuming uniform node distribution, this characteristic, favours a more load balanced clustering operation. Every sector in this $2-d$ coordinate space is mapped to a unique \emph{region} in the DHT space forming a multi-layer node identifier space. Thus, any nodes that belong to the same sector, are mapped to the same region as well, preserving their proximity relationship unveiled by the use of the Vivaldi protocol.
%
%\paragraph{Routing table optimization}
%The system described in the previous section allows any node $\alpha$ to obtain its DHT's $key_{\alpha}$ and its region's $key_r$, in a fully distributed manner, just by applying a consistent hash function. Using a $Get\left( key_r \right)$ RPC call in Chord, the node can obtain the region's master node, called \emph{Cluster Node (CN)} which is responsible for clustering the nodes belonging in the same sector or region with that of $\alpha$. On the other hand, a $Put\left( key_r, info\right)$ RPC call, registers $\alpha$ to its corresponding region and publishes its information, through the special peer CN. $\alpha$ can, additionaly, ask CN for other nodes that have previously joined the region in order to add them into its neighbour set for future routing table optimization. Even in the case when no neighbour is detected in the current region, the search is expanded to adjasent regions and towards an upper layer identifier space until one is found or the first layer reached.
%
%\subsection{Quasi-Chord}
%
%\paragraph{}
%The approach that is proposed by Sun and Zhang in \cite{sun_quasi_2008} confronts the topology mismatch problem, in the Chord DHT context, that is created by the fact that no consiteration for the underlying physical network topology is taken into account during the construction of the identifier cycle. To construct a \emph{Quasi-Chord} network three steps are needed. First, each host acquires its coordinates in the geometric space utilizing the \emph{global network position (GNP)} protocol \cite{ng_gnp_2001}. Second, using the \emph{Cantor space filling curve} the $2$-dimensional space is converted to a $1$-dimensional one, used in the last, third, step to build the Quasi-Chord circle according to the host's Cantor value. In the following paragraphs, these steps are furtherly discussed.
%
%\paragraph{GNP coordinates}
%First of all the host must be positioned in the geometric space. The algoritm models the P2P network with a well defined distance function in such a way, it can predict, with high accuracy, the distance between any two points in the space by just evaluating the output of the distance function on the coordinates of these points. This is accomplished with the \emph{global network position (GNP)} protocol which\begin{inparaenum}[\itshape i\upshape)]
%  \item creates a reference set of $N$ landmark nodes so as to minimize the error of ICMP measured distances and coordinate computed ones between them, and then
%  \item each host is able to measure its round-trip times to the $N$ Landmarks in order to compute its own coordinates.
%\end{inparaenum}
%
%\paragraph{Cantor SPF}
%After the $2$-d coordinates are set, in the next stage of the algorithn, each participating peer is assigned a Cantor value, according to the application of a \emph{space filling curve} on the coordinate space. (TODO: add figure). This results in the conversion of the $2$-dimensional space to a $1$-dimensional Cantor space that can more easily be more mapped to the Chord hierarchy.
%
%\paragraph{Quasi-Chord construction}
%As can intuitively be infered by observing the Cantor chart, close-by nodes in the physical layer, are more likely to have similar Cantor values. This attribute is exploited in order to construct a topology-aware identifier space for the Chord DHT. The cycle is constructed by sorting nodes in ascending order. Each host maintains 2 finger tables, one for clockwise and one for counter-clockwise stepping. This helps with the connectivity of the network because its not allowed to connect the first node with the last one since this will incur heavy traffic to the later\footnote{After all their Cantor values denote that they are actually the furthest of each other.}.
%
%\paragraph{}
%% TODO: doublecheck!
%The disadvantage of the algorithm is that the coordinate assignment in the first stage is backed by a not fully distributed landmark-based algorithm. Moreover the Quasi-Chord model build-up is making an indirect assumption of a maximum number of allowable hosts since it is constructed. Last but not least the doubling of the required routing information which needs to be created and maintained is an additional negative point to the efficiency and the scallability of the algorithm.
%
%\subsection{LAPTOP}
%{\sethlcolor{yellow}\hl{HA - two important issues for decentralized structured P2P:
%P2P applications. However, the design of a decentralized but structured P2P network has to
%overcome two critical issues. The first issue is the long routing latency. Several proximity
%schemes  have been proposed to avert long routing latency in current structured P2P
%networks, but they require a high-complexity procedure to periodically maintain the routing
%table (e.g. Pastry system) or they need pre-chosen landmarks to construct the overlay.
%However, the P2P system is by its very nature unstable since nodes join and leave frequently.
%For instance, the study of Gnutella shows around approximately 1200 membership changes
%per minute in a 100 000 nodes P2P system. Another proximity scheme needs some pre-chosen
%landmarks or a complete BGP routing table support. As a result, they both increase the
%difficulty of the P2P system deployment.
%The second issue is system maintenance overhead. The existing structured P2P networks allow
%nodes to keep some nearby nodes in their routing tables in order to achieve efficient routing. The
%}}
%
%\paragraph{}
%Laptop \cite{wu_laptop_2007}, introduced by Wu et al., organises the overlay into a tree based hierarchy with main focus on child-to-father relationships in order to reduce hops during message routing as well as minimize maintenance overhead. Additionally, a caching scheme is also incorporated so as to furtherly reduce routing table update cost. The authors argue that Laptop overlay network is bounded by $O\left( log_d N \right)$ hops in a balanced overlay tree, where $N$ is the number of nodes, and $d$ is the maximum degree of each node. It utilizes a geographical layout approach  and constructs a geographical layout in a self-organizing and efficient fashion, by estimating the round trip time (RTT) to a small number of nodes in the overlay network in order to make them roughly aware of their physical distances among them.
%
%\paragraph{}
%The protocol is based on four definitions.
%\begin{enumerate}
% \item The amplitude of all possible measured RTTs is devided into intervals. Each node measures its distance to its parent and is assigned a label $L_i$ where $i$ denotes the configurable RTT interval in which the measured distance falls into. A special kind of node, the root, is initially assigned the $L_1$ label and maintains (as all $L_1$ nodes do) a list of other $L_1$ nodes in the overlay.
% \item Any node can have children with level lower than theirs, except an $L_{max}$ node which can only have $L_{max}$ level children and only in the case when its parent has reached its maximum degree.
% \item Each node is assigned an address in a dotted format (e.g 1.3.4). Each octet ranges from $1$ to $d$, where $d$ is the maximum degree of the nodes. The assignment process is done by appending a unique octet to the address of its parent. Root node is assigned address 1.
% \item For any descendant node $Y$ of a node $X$, the measured distance among each other, must always be less than the lower bound of the RTT interval denoted by $X$'s label.
%\end{enumerate}
%
%\paragraph{}
%The routing scheme is similar to the IP's longest-prefix matching scheme. At each forwarding hop, any message travels up the tree until the first common uncestor of source and destination node is reached and then starts descending to arrive to its target. During tree traversals, special entries in the routing tables, called \emph{routing cache}, are maintained in order to increase routing efficiency and achieve finer load balance. Caching enables a node to forward a message to a better longest-prefix match than that of its direct ancestor making a large, quicker and more cost effective step through the overlay and toward the destination. To improve scalability, the number of children nodes and the size of the routing cache are limited.
%
%In terms of overlay maintenance, Laptop incorporates a simple \emph{heartbeat}-based technique where only the parent node is responsible for monitoring its children.
%
%At join process the newcomming node is assigned its level label as well as its address by its parent node. Additionaly it initializes its routing table (with normal and caching entries) as it traverses the overlay in search for its parents node.
%The newcommer $N$ locates the root node and the later responds with a list of $L_1$ nodes. $N$ then probes each of the $L_1$ nodes in search for the closest one. If the measured RTT to the closest $L_1$ falls into the first interval then the newcommer becomes a $L_1$ node as well. Otherwise node $N$ sets the closest $L_1$ node as its potential parent node. This potential parent becomes the actual parent if it does not have any other children. If it has, $N$ gets a list of these $L_i$ nodes and by measuring the RTT to each of them tries to spot a new potential parent in order to repeat the above process.
%
%\paragraph{}
%During a gracefull departure, the refered node checkes for children in the overlay. If it does not have any, it simply notifies its parent and leaves. If it has, it selects the child node with the lowest RTT to it in order to take its place so that the locality property is preserved.
%
%In case of an arbitrary failure, the children of the failed node are detecting their parent's absent when the later stops acknowledging their heartbeat messages. They start emmiting special messages to their grand parent node\footnote{The address of the grandparent node is stored during join process}. In case of no response from the grandparent node, children invoke the joining procedure to detect their new parent node.The parent of the failed node, aggregates the notifications from the above children nodes for a period of time, and then chooses the one with the lowest level label as the takeover node. Potential ties are broken by favouring the lower RTT. The parent of the failed node, finally informs accordingly all the children about the change in the hierarchy.
%
%\subsection{IP-based Clustering (IPBC)}
%
%\paragraph{}
%\emph{IP-based clustering} \cite{karwaczynski_ipbc_2007} is a proximity neighbour selection technique that is based on a longest IP prefix matching scheme in order to quantify the proximity among peer nodes. The relation of the IP address and the physical location of a node in the topology of the Internet, is intuitevely realized by operation the network layer of the Internet stack. For example, nodes in the same local subnetwork share the same 3 bytes of their address. Reports in \cite{freedman_iploc_2005} state that almost $97\%$ of prefixes longer than 3 bytes correspond to address assignments at a single geographic location. Moreover, observing the \emph{IANA IPv4 Address Space Registry} we can infer that, since blocks of consecutive octet prefixes are assigned to the same Regional Internet Registries (RIRs), nodes inside will be physicaly close to each other.
%
%\paragraph{}
%The implementation in this paper is based on the above observation in order to create proximity information. This information is stored in a decentralised manner, within the overlay itself, just like any other resource would have been. In order to be published in the overlay, each node is first assigned a unique identifier and subsequently generates a key by hashing a fixed-length prefix of its IP. Authors argue on the prefix length to be used, as there is a thin balance between reducing the propability of finding closer nodes by adopting a long prefix and overload nodes that are responsible for information published by many peers when chosing to hash a short one. Their verdict is for the use of a 16-bit wide prefix for real world systems deployed in an Internet scale. In either case, ID and IP is then stored in the DHT using this generated key. This way, any node, at any time (either at join time or during peer lifetime for topology adaptation) can acquire information about close-by nodes just by quering the DHT for a specific key. Moreover, the algorithm takes care of the freshness of the proximity information in two ways. First, the advertising nodes themselves periodically update their advertisements or when they voluntarily leave the overlay, they explicitly remove their data. On the other hand, in case of a failure each publication is assigned an expiration time, and thus ultimately removed by the DHT maintenance mechanisms.
%
%\subsection{CHOord considering Proximity on IPv6 (CHOP6)}
%
%\paragraph{}
%\cite{morimoto_chop6_2007} roughly estimates the proximity among nodes by exploiting the IPv6 address format as well as RTT information if this is available.The first is achieved by introducing a 64-bit ID scheme in which the least significant bit part\footnote{The exact range is a predefined system variable} is the IPv6 global routing prefix and thus enabling a longest prefix match scheme. The observation in which the protocol is based roots from the IPv6 address block assignment. Specicaly, block of /16 or /23 in size are assigned to Regional Internet Registries (RIRs) by Internet Assigned Numbers Authority (IANA). An RIR divides the signed address blockes into smaller address blocks which are furtherly assigned to Natinal Internet Registries (NIRs). That way, it is possible to estimate a node's geographical location by simply examining the upper 32-bits of its IPv6 address. Moreover, similar to Chord, CHOP6 uses a finger table, whose entries hold more than one candidate nodes. There are three cases in which a node chooses the next hop according to information it posseses.
%\begin{itemize}
% \item When no information about RTT is available candidate next hops, the sender just selects a node in the finger table entry which shares the longest prefix with the destination.
% \item There is another possibility that after some communication with other nodes, the source node should know of the RTTs to some of the nodes in finger table entry. In this case, the source node chooses the one with the smallest RTT with propability $p$. If there is a node with no measured RTT then the sender can select such a node with probability $1 - p$
% \item In this last case the source node has already communicated with all candidate node in the finger table entry. Thus, the node selects the node whose RTT is the smallest with probability $p$, the one with the second smallest with probability $q$ and so on, where $0 \leq \ldots < r < q < p < 1$ and $p+q+r+\ldots \leq 1$
%\end{itemize}
%
%\subsection{Proximity in Kademlia}
%
%\paragraph{}
%In \cite{kaune_pkad_2008}, Kaune et al., studied the Kademlia DHT, in order to build a proximity aware scheme that would work in the context of iterative lookup algorithms. The protocols discussed, focus on both the overlay and underlay tiers in the sense that in the first improves the routing performance according to a cost metric that is provided by the later. This metric is tailored to the needs of a specific aplication. For example, routing could be optimised to maximise the within-ISP traffic or reduce the lookup latencies or even avoid contacting untrustworthy subnetworks.
%
%\paragraph{}
%Two algorithms are presented for the overlay optimization. One is \emph{Proximity Neighbour Selection (PNS)} and one for \emph{Proximity Route Selection (PRS)}. The first aims at keeping peers with the least contact cost in the routing table. As Kademlia constantly learns new peers (incoming requests, through iterative lookup) no special algorithm for searching more cost effective peers is necessary and simply choose the best peers seen so far. The later (PRS) aims at choosing the best next hop during routing a message. Due to the fact that the routing in Kademlia is iterative, it is the initiator of the lookup that chooses each next hop from a set of candidate nodes. The ``vanilla'' Kedemlia always chooses the closest node with respect to the XOR metric but PRS Kademlia chooses the one with the smallest underlay metric cost. Thus, as in all such approaches, there is a trade-off between the overlay and underlay distances.
%
%An underlay metric provides information about the underlay network. The paper distingushes between three kinds of possibilities to quantify it:
%\begin{itemize}
% \item Using measurements gained by previous lookups
% \item Using measurements acquired by other peers or jointly calculated with others
% \item Using a local database to look up information
%\end{itemize}
%In the paper, for locality of traffic and subsequently for reducing the lookup latency, a clustering scheme has been implemented exploiting information stored in a geographic information database (GeoIP,MaxMind) about peers. The goal of such a metric is to constrain the largest portion of communication within the limits of a peer's ISP.
%Another incorporated approach is Vivaldi\cite{cox_vivaldi_2004}. At first all coordinates are random but as peers start to communicate they calculate RTTs as well, gradually updating their own coordinates. Vivaldi creates a system where a peer knowing the coordinates of a another, can approximate communication latency without the need of additional prompting.
%
%\subsection{Cone}
%
%\paragraph{}
%Cone\cite{wang_cone_2007} uses a two-layered identifier space. The first, named Chord-layer identifier, denoted as $Id_{Chord}$, is the same as in ``vanilla'' Chord. The second is the Cone-layer identifier, $Id_{Cone}$ which is constructed by two component identifiers. The first, known as \emph{group identifier (gid)} denotes a relevant group the node belongs to while the second, namely \emph{local identifier (lid)} indicates the local identifier within the group. The group concept, which is introduced here, is a way of dividing nodes according to a common $Id_{Chord}$ prefix.
%The structure of a Cone overlay, retains the Chord's circular topology. The differce lies on the fact that, now, two rings are created. A big ring, where nodes with the same \emph{gid} are arranged at each position. Each of these positions are a smaller ring for the particular group's \emph{lid}s. The routing is achieved in both clockwise and anti-clockwise direction in the big-ring. For this reason two routing tables are maintained, namely \emph{front} and \emph{back} finger tables, respectively. Entries in these tables, display physical network proximity with the current node. Moreover, a third table called \emph{group} table maintains information about other online peers within the current node's group in a way that entries are now close in the ID space.
%
%\paragraph{}
%Routing in Cone, comprises of the inter-group algoritm and the intra-group algorithm. First the group of nodes to which the desired key lies is detected, exploiting physical proximity information (front and back finger tables). Second during the next and last hop, the message is forwarded to the exact node that contains the desired key.
%
%Cone uses Landmark+RTTs to generate proximity information and exploits this information using proximity neighbour selection.
%
%\subsection{DynaMO}
%
%\paragraph{}
%In their work in \cite{winter_dynamo_2004}, Winter et al, try to build an overlay network, called \emph{DynaMO}, that tries to consider not only the physical proximity of peers but their mobility attributes as well. DynaMO is based on a Pastry overlay network. This was an intentional choice from the authors because Pastry's built-in locality heuristics are thoroughly analised in the literature \cite{castro_proximityp2p_2002} providing good backround against which to test and compare their results.  In order to adapt to mobile, ad-hoc networks, though, special care has been put to the maintenance of an even overlay ID distribution so that hot-spots are avoided. Pastry assignes them in a randomised fashion and then tries to consider proximity through the joining process and routing table maintenance. On the other hand, DynaMO dictates a newcoming node to gather information concerning its physical neighbourhood and uses it to assign itself an appropriate overlay ID.
%
%DynaMO tries to capitalize an observation of Pastry's routing mechanism. Each node's table consists of rows equal to the number of digits of the overlay IDs and columns equal to the ID's base. As we go down the table rows, the matching prefix between the current node's ID and the row's entries increases by one. Thus, the leaf set contains the closest nodes in the ID space. Additionally as the prefix match increases by one, the result is exponentially less candidates that can fill the tables entries as the row increases. This leads to the observation \cite{antony_pastry_2001,castro_proximityp2p_2002} that from overlay routing hop to overlay routing hop the physical distance between nodes is likely to increase leading to a dominating last routing step in terms of the overall plysical routing path distance travelled during a key lookup. Since the last routing step is usually taken from the leaf set, DynaMO focuses on making this last step as physicaly close as possible. In this context, two approaches are considered namely \emph{Random Landmarking (RLM)} and \emph{Closest Neighbour Prefix Assignment (CNPA)}.
%
%\paragraph{}
%Random Landmarking uses the overlay lookup mechanism to locate nodes responsible for a fixed set of carefully chosen\footnote{In a way that the ID space is divided into equal portions} landmark keys. This means that when a node is assigned a landmark key then it plays the role of a temporary landmark for the network. Any joing node will measure its distance to that and all other landmarks and assign to itself an ID consisting of a prefix taken from the closest landmark and a remainder that could be assigned randomnly or generated by mechanism that takes into account physical neighbourhood. The legth of the prefix can be determined as $prefix_length=|log_b k|$, where $b$ is the ID base and $k$ the number of landmarks. The above scheme results in physically close nodes, forming regions of common ID prefix that are likely to be close to each other in the ID space and thus bringing a node's leaf set closer to itself. Additionally, the advantage of dynamic landmark nodes is that the failed ones can instantly be replaced by new responsibles, that share similar physical attributes to the failed and thus preserving the balance of the network.
%
%\paragraph{}
%RLM may incur more traffic especially on landmark nodes, load that in some cases is not acceptable. CPNA on the other hand takes advantage of Pastry's specification that a new coming node is bootstraped by a physicaly close node. The new comer then assumes the ID prefix of that neighbour while the rest is generated similarly to RLM. Unfortunately, less overhead comes at the expense of being more coarse-grained.
%
%\paragraph{}
%Both algorithms, are protected against the formation of physical landmark clusters or imbalanced ID distribution\footnote{More common during the initial formation of an overlay network} , by introducing the \emph{landmark gravitation range} as a theshold over which landmark keys are reassinged (for the RLM approach) or unutilized ID prefix ranges are detected and used (for the CPNA scheme) in order to balance the distribution of regions in the overlay.
%
%\subsection{PChord}
%\emph{PChord}\cite{hong_pchord_2005} is a based on the Chord DHT which adds proximity routing into its routing mechanism. The main modification over the ``vanilla'' Chord is the inclusion of a \emph{proximity list} into its routing table so that the next hop is decided based not only by considering best progress towards the key, but on the physical proximity of the candidate nodes as well. The list is, at join time, empty but as the PChord node starts to interact with other nodes it applies a heuristic mechanism to fill up the list. Entries are dynamicaly added or removed as the network state is constantly changing. Because, it is guaranteed that at each routing step there is progress towards the target node in the ID space, PChord will result in lower hop number than Chord, for each hop is larger or at least equal in key space in PChord than in Chord. Additionaly, passing through proximity links in the underlay means reduced routing cost. Moreover, if the number of entries in the proximity list is the same as the number of network partitions, PChord prevents hops from jumping back to the same network the current node belongs to.
%
%\subsection{AChord}
%\emph{AChord}\cite{dao_achord_2006} uses IPv6's anycast functionality in order to
%\begin{itemize}
% \item releave the protocol from complex joining procedures, and
% \item achieve high accuracy of network proximity giving high routing efficiency,
%\end{itemize}
%all with a simple and lightweight mechanism that requires few changes to Chord without affecting its own advantageous characteristics. Anycast delivers a message comming from the outside of an anycast group to the physicaly closest node in that group. AChord organizes all nodes participating in the overlay network into an anycast group. Any joining node comes outside of that group and, thus, is automaticaly forwarded to the physicaly nearest node in order to bootstrap, avoiding
%\begin{inparaenum}[\itshape i\upshape)]
%  \item the need to, explicitly, maintain such nodes, and
%  \item the effort of finding a way of locating the physically nearest among them.
%\end{inparaenum}
%The ID of the new comming node is computed based on the ID of the bootstrap node and bootstrap's predecessor in a way that its ID will position itself between the formentioned.
%
%After joining, the finger table is build the same way as in the Chord protocol. Moreover, additional nodes are maintained in a structure called \emph{neighbourship table} which stores information about the closest known nodes\footnote{As a first entry, at bootstrap, the node stores information about the bootstrap node.}. The routing decision is made by using both the neighbourship and the finger table.
%
%\subsection{Chord6}
%\emph{Chord6} \cite{xiong_chord6_2005} is a Chord variant that tries to exploit the hierarchical features of IPv6 in order to create a substrate that reduces interdomain trafic and does that in a cost efficient way. Chord6 bareley modifies the original Chord protocol, only in the part of identifier definition. This, renders the aproach easily portable to other DHTs such as CAN, Pastry and Tapestry. In Chord6 the identifier contains two pares: the higher bits are obtained by hashing the  node's IPv6 address prefix of specific length, while the remaining lower bitss are the hash value of the rest of that IPv6 address. This way nodes in a domain will be mapped onto a contihuous key space on the overlay network. This guarantees that messages are routed in a way that they do not hop in and out of domains many time, thus minimizing overall routing cost. (TODO: Recheck validity) However, even though nodes in the same domain would have close identifiers, nodes in two close domains may have very different ones.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{acmtrans}
\bibliography{mard-survey}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{received}
Received Month Year;
revised Month Year; accepted Month Year
\end{received}

\end{document}
