\section{Structured \p\ Networks}
\label{section:structured}

This section presents a description and analysis of algorithms proposed
to address the topology mismatch problem in structured \p\ networks. The
categorization of the approaches we present here is based on how different
levels of proximity information is gathered and the way peer routing tables are
maintained and used in an effort make overlay hops as efficient as possible. The
categorization is based on previous work found in the
literature~\cite{CDHR2002,CDCR2002,RSS2002}.

%% VM Rephrased as above to keep it analogous to the opening paragraph of
%% the unstructured part.
%%
% This section presents a description and analysis of algorithms proposed
% to address the topology mismatch problem in structured \p\ networks.
% In structured \p\ networks, the construction of the routing tables
% held by participating nodes determines the efficiency of message forwarding.
% Routing tables that closely match the underlying IP topology
% achieve increased performance. As a result, the proposed solutions for
% the topology mismatch problem for structured \p\ networks
% use different levels of proximity
% information to optimize the routing tables used by peers.
% The categorization of the algorithms we present here is based on the
% categorization suggested by previous
% work~\cite{CDHR2002,CDCR2002,RSS2002}.

\subsection{Algorithms for Structured Architectures}

%###############################################################################
%###############################################################################
%###############################################################################
%       GEOGRAPHIC LAYOUT
%###############################################################################
%###############################################################################
%###############################################################################

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Global Soft-State}

% \begin{figure*}
% \centering
%   \includegraphics[scale=0.8]{img/algorithms/global_softstate}
% \caption{(left) Position of $p$ in the space of $3$ landmarks. (right) Position
% of $p$ on the map.}
% \label{fig:global_softstate}
% \end{figure*}

\emph{Global Soft-State} \cite{XTZ2003} builds a global map to help
choose shorter routing paths, combining the landmark binning method and small
scale distance probes to reveal the proximity properties of the underlying
network. %Figure \ref{fig:global_softstate} presents the landmark
%space and the mapping of the position of the nodes.
This global view of the
state, is made available to all nodes to help them find the best way to
route their messages. \emph{Global Soft-State} operates in two phases:
generation and use of the proximity information. For generating the proximity
information, a hybrid approach is proposed, which uses landmark clustering as a
preprocessing step to select a number of potential nearest neighbor
candidates and then refine the selection by incorporating a
round-trip-time-based scheme to ultimately choose the closest node. For using
the proximity information, the algorithm follows a different path from that of the
classic gossiping approaches for the construction and maintenance of the
overlay. It is based on landmark clustering for generation and strategic
placement of proximity information on the overlay. This information is called a
``map'' and concerns a region of the overlay (part of the Cartesian space in
structures like eCAN\cite{xu_ecan_2002} or a set of nodes sharing a particular
prefix in overlays such as Pastry\cite{antony_pastry_2001}). Thus, each node not
only can access such information from these landmarks but can also subscribe to
relevant \emph{soft states} and get notified on dynamic network changes. A
node may appear in a maximum of $log\left( N \right)$ such
maps.
%%
Although this approach greatly reduces the routing latency to far nodes, it
comes expensive. It is possible to end up with a very large number of regions
each of which has to maintain a map. The fact that a peer may appear in multiple
such maps we can conclude that additional traffic for probing and notifications
renders the approach not scalable \cite{RGJZ2004}. Moreover, to refine measurements
additional inner-bin measurement s are required\cite{WZS2004}. Also improvement
is done within a region because of little knowledge about neighboring zones.

%% VM Removed most of the paragraph below which contains info that we cannot back
%% Rescanned papers and wrote the paragraph below.
%% DO NOT PERMANENTLY DELETE!
%%
% Unfortunately, maintained of several host states at different layers,
% renders any content migration a costly process. Additionally, the method does
% not make any continuing effort to remap
% the overlay structure after nodes successfully join resulting into poor
% adaptation to changing conditions. Although this approach greatly reduces the
% routing latency to far nodes, it is unable to dynamically identify nodes that
% are close to routers and gateways in order to construct the secondary overlay.
% Nevertheless, static recognition of such nodes is currently done based on BGP
% reports and pre-chosen landmarks, sacrificing the self-organizing attribute of
% traditional DHTs.

%
% TODO: SOME DISCUSSION
%
% Xu \textit{et al.} \cite{XTZ2003} state that there are three ways
% generating proximity information
%\begin{itemize}
% \item Expanding Ring Search\\
%Expanding ring search can be of two forms. First it can utilize the multi-cast
%infrastructure in the underlying network in order to emit its messages.
%Unfortunately such infrastructures are not widely deployed thus the
%implementations of this way of generating proximity information is limited to
%blindly flooding the neighborhood to obtain reasonable results.
%
% \item Heuristics\\
%Heuristics are used in order to reduce the blindness of the expanding ring
%search and make realizations more efficient and effective. Unfortunately a
%common problem of all heuristic approaches is the local minimum pitfall in
%which
%the search might be caught into.
%
% \item Landmark Binning\\
%Landmark clustering is based on the view that nodes with similar distances to a
%set of predefined well-known landmark nodes are pretty likely of being close to
%each other. But this approach has its weaknesses as well, such as the fact that
%is a rather coarse grained approximation, therefore not particularly well
%suited
%for differentiating nodes within close distance to each other.
%
%\end{itemize}
%
%

%
% TODO: IN PAPER INTRODUCTION A DISCUSSION ABOUT
%TOPOLOGY-AWARE CAN
%
%Techniques to exploit topology information in overlay
%routing include geographic layout, proximity routing and
%proximity neighbor selection [3]. With geographic layout
%such as topology-aware CAN [12], the overlay structure is
%constrained by underlying network topology. This tech-
%nique, unfortunately, can create uneven distribution of
%nodes in the overlay, increasing the chances of overloading
%nodes and rendering the maintenance cost formidable. Our
%study shows that, for a typical 10,000-node topology-aware
%CAN, 5% nodes occupy 85-98% of the entire Cartesian
%space, and some nodes have to maintain 450-1500 neigh-
%bors. In Proximity routing, physical topology is not consid-
%ered when constructing the overlay.
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Unable to identify nodes that are close to routers but it can reduce routing
% latency to far away node by approximately 50-75%.
medium &
% maintenance of node states, subscriptions and notifications need global
% overview of the overlay resulting in high control overhead
high &
% Statically implemented sacrificing the decentralized nature of DHTs and
% thus poorly scaling. Also we can end up with a very large number of regions.
% Because of the fact that a peer may appear in multiple
% such maps we can conclude that additional traffic for probing and notifications
% renders the approach does not scalable.
low
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Mithos}
\emph{Mithos} \cite{WR2003} is a \p\ protocol which incorporates directed
incremental probing to find near optimal node placement, and is an integration
of geographic layout and proximity routing overlay optimization methods.

The bootstrap phase of \emph{Mithos} starts with a subset of existing members as
the first set of candidates, and while the closest nodes are detected by iteratively
probing the neighborhood, the candidate neighbor list is updated. To
avoid local minima, \emph{Mithos} probes all the neighbors within a two-hop distance
from the current minimum before concluding the process.

After finding its first neighbor, the new-coming peer is assigned an ID using
information gathered during the iterative neighbor selection phase. Based on the
two closest nodes found, along with these nodes neighbors and the corresponding
distances a system of virtual springs is set so that the tension of each spring
is inversely proportional to the distance. The system is then left to settle,
and the state in which it settles is used for its ID. The benefit of these
synthetic coordinates are that
they are explicitly used as the node's ID, and distance computations among nodes
can be done in ID space without requiring physical measurements.

The last step of the algorithm is the interconnection among neighbors. \emph{Mithos}
uses a \emph{quadrant-based} mechanism in which each node establishes
a link to the closest neighbor in each quadrant. During forwarding, the next
hop is performed towards a neighbor in the same quadrant as the final
destination. The new coming node may not know of other neighbors in all
quadrants, therefore, the node first identifies neighbors in all quadrants
using a mechanism based on ideas similar to a perimeter walk\footnote{Used in
the Greedy Perimeter Stateless Routing (GPSR) protocol.} and then improves the
results using parallel path processing by taking into account further geometric
properties of node relationships.

One major limitation of \emph{Mithos} is that the protocol cannot effectively
handle dynamic arrivals and departures from the network. In \cite{CCRK2004} it
is claimed to need extensive probing to determine distances and at the same time
its results are evaluated as less accurate than, for example,
GNP \cite{ng_gnp_2001}. Maybe this has also to do with its iterative neighbor
selection process which is reported to be prone to prematurely terminate at
local minima \cite{WSS2005}. Another point that has negative effect to the
scalability of the algorithm is that parts of its spring relaxation technique
require a centralized implementation~\cite{cox_vivaldi_2004}.

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% It has very good results in reducing communication latency among peers but its
% efficiency is being constrained by the fact that the proximity is calculated
% at bootstrap, assigning virtual coordinates that are used throughout of a
% nodes life cycle and thus the overlay is not adapting to a high-churn
% environment.
medium &
% Incremental probing is applied in quadrants and in two-hop distance at each
% step that does not generate a lot o control overhead.
medium &
% It is constrained by the fact that the protocol does not respond to dynamic
% peer arrivals and departures
low
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{LAPTOP}
\emph{LAPTOP} \cite{WLH2007}, organizes the overlay into a tree-based hierarchy
with the goals of reducing hops during message routing as well as minimizing
maintenance overhead. Additionally, a caching scheme is also incorporated so as
to further reduce routing table update costs. It is theoretically shown
that in \emph{LAPTOP}, routing path length is bounded by $O(log_d N)$ and node
joining and leaving in the overlay network is bounded by
$O\left( d log_d N \right)$ hops in a balanced overlay tree, where $N$ is the
number of nodes, and $d$ is the maximum degree of each node. \emph{LAPTOP}
implements the geographical layout approach  and constructs its layout in a
self-organizing and efficient fashion. The physical distances are estimated
with round trip times to a few existing nodes in the overlay network.

Each node is assigned a dot-formated address (e.g 1.3.4). Each octet ranges from
$1$ to $d$, where $d$ is the maximum degree of the nodes. The assignment process
is done by appending a unique octet to the address of each node's parent, while
the root node is assigned address $1$.

%The protocol is based on four definitions.
%\begin{enumerate}
% \item The amplitude of all possible measured RTTs is divided into intervals.
%  Each node measures its distance to its parent and is assigned a label $L_i$
% where $i$ denotes the configurable RTT interval in which the measured distance
% falls into. A special kind of node, the root, is initially assigned the $L_1$
% label and maintains (as all $L_1$ nodes do) a list of other $L_1$ nodes in the
% overlay.
% \item Any node can have children with level lower than theirs, except an
%  $L_{max}$ node which can only have $L_{max}$ level children and only in the
% case when its parent has reached its maximum degree.
% \item Each node is assigned a dot-formated address (e.g 1.3.4). Each octet
% ranges from
% $1$ to $d$, where $d$ is the maximum degree of the nodes. The assignment
% process
% is done by appending a unique octet to the address of each nodes parent, while
% root node is assigned address $1$.
% \item For any descendant node $Y$ of a node $X$, the measured distance among
%  each other, must always be less than the lower bound of the RTT interval
% denoted by $X$'s label.
%\end{enumerate}
%

The routing scheme is similar to the longest-prefix IP matching scheme. At each
forwarding hop, any message travels up the tree until the first common ancestor
of both source and destination nodes is reached and then starts descending to
arrive to its target. During tree traversals, special entries in the routing
tables, called \emph{routing cache}, are maintained to increase routing
efficiency and achieve finer load balance. Caching enables a node to forward a
message to a better longest-prefix match than that of its direct ancestor making
a larger, quicker and more cost effective step through the overlay and toward
the destination. To improve scalability, the number of child nodes and the
size of the routing cache are limited. In terms of overlay maintenance, \emph{LAPTOP}
incorporates a simple \emph{heartbeat}-based technique where each parent node is
responsible for monitoring its children.

%
%The new comer $N$ locates the root node and the later responds with a list of
%  $L_1$ nodes. $N$ then probes each of the $L_1$ nodes in search for the
% closest one. If the measured RTT to the closest $L_1$ falls into the first
% interval then the new comer becomes a $L_1$ node as well. Otherwise node $N$
% sets the closest $L_1$ node as its potential parent node. This potential
% parent becomes the actual parent if it does not have any other children. If it
% has, $N$ gets a list of these $L_i$ nodes and by measuring the RTT to each of
% them tries to spot a new potential parent in order to repeat the above
% process.
%

% At join process the new coming node is assigned its level label as well as its
% address by its parent node. Additionally, it initializes its routing table
%(with normal and caching entries) as it traverses the overlay in search for
%its parent node.  During a graceful departure, the referred node checks for
%children in the overlay. If it does not have any, it simply notifies its
%parent and leaves. If it has, it selects the child node with the lowest
%round-trip time to it in order to take its place so that the locality
%property is preserved. On the other hand, in the case of an arbitrary
%failure, after the children of the failed node detect their parent's absence
%(through the aforementioned heartbeat mechanism), they start emitting special
%messages to their grandparent node (the address of which is stored during
%join process}. In case of no response from the grandparent node, the children
%invoke the joining process to detect their new parent node.The parent of the
%failed node, aggregates the notifications from the above children nodes for a
%period of time, and then chooses the one with the lowest level label as the
%takeover node. Potential ties are broken by favoring the lower RTT. The
%parent of the failed node, finally informs accordingly all the children about
%the change in the hierarchy.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% TODO: HERE STRUCTURED LANDMARK BINNING APPROACH LIES
%
%Assuming a structured approach based on CAN\cite{ratnasamy_can_2001} and $m$
% landmark nodes. The coordinate space is then partitioned into $m!$ equally
%sized portions, each corresponding to a single ordering of the landmarks. To do
%this, the first dimension is divided into $m$ areas each of which is further
%divided (second dimension) into $m - 1$ sections and so on. Having set this $m$
%dimensional space, at joining time, a node measures the delay to the set of
%landmarks in order to determine its associated bin and thus position itself in
%that portion of the coordinate space associated with its landmark ordering.
%Even though this scheme can
%


\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% It minimizes routing length, but may suffer load imbalance since nodes higher
% in the tree hierarchy are more likely to route most of the messages in the
% overlay.
medium &
% Heartbeat approach incurs extra control overhead to the network. Fortunately
% involves only the parent and the children of the departing/failing node.
% nodes.
low &
% Seems to scale nicely from 10K- to 1M-node testbeds.
high
\end{tabular}
\end{center}


%###############################################################################
%###############################################################################
%###############################################################################
%       PROXIMITY ROUTING
%###############################################################################
%###############################################################################
%###############################################################################


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Proximity in Kademlia}
% Before discussing {\em Proximity in Kademlia}, it would be helpful to briefly
% summarize the highlights about the {\em Kademlia} protocol. {\em Kademlia}
% \cite{maymounkov_kademlia_2002} is a distributed hash table (DHT) based
% protocol for \p\ networks, which uses an iteration based lookup algorithm. The
% protocol uses the standard $160$ bit ID system for nodes and locates the nodes
% in a prefix binary tree, where IDs are used as prefixes. The iterative lookup
% operations are done over this prefix binary tree, which converges to
%logarithmic
% lookup times. The ID's are assigned randomly, therefore in Kademlia, there is
%no
% proximity control, which results in inefficient use of the underlying network
% during lookup and retrieve operations.

\cite{KLKP2008} introduces proximity
controls over the vanilla Kademlia protocol's random ID assignment to
optimize the underlying network usage.
% The work in this paper
% can also be considered as a more generic study of incorporating proximity into
% iterative lookup algorithms.
The overlay tier improves its routing performance using a cost metric that is
provided by the underlying tier. Such information can be acquired by
\begin{inparaenum}[\itshape i\upshape)]
  \item measuring previous lookups,
  \item exchanging measurements of other peers or jointly calculating them with
  others, or
  \item using a local database to look up information.
\end{inparaenum}

Regarding routing optimization both techniques of \emph{proximity routing
selection (PRS)} and \emph{proximity neighbor selection (PNS)} are studied.
%%
In \emph{PRS}, the goal is to choose the best next hop during routing a message.
% Due to the fact that the routing in Kademlia is iterative, it is the initiator
% of the lookup that chooses each next hop from a set of candidate nodes.
Plain old Kademlia (\emph{POK}) always chooses the closest node with respect to
the XOR metric but with proximity routing, Kademlia should also choose the node
that exhibits the smallest underlay metric cost, balancing a trade-off between
the overlay and underlay progress distances.
%%
In \emph{PNS}, on the other hand, the goal is to keep peers with the least
contact cost in the routing table. As Kademlia continuously learns about new
peers via incoming requests and an iterative lookup process, no special
algorithm for searching more cost-effective peers is necessary and it simply
chooses the best peers seen so far.

Proximity injection in Kademlia improves locality of connections between peers.
Towards the enhancement of traffic locality, it is suggested to use information
from the MaxMind GeoIP database\footnote{http://www.maxmind.com} and use it to
form clusters of nearby peers. An other alternative method could use Vivaldi
coordinates \cite{cox_vivaldi_2004}, however, it is suggested that the
clustering approach performs better. Specifically when combined with both
\emph{PRS} and \emph{PNS} preserves more than $40\%$ of the messages within an
ISP and allows only a small $6\%$ to go through intercontinental backbones.

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Uses static information to cluster nodes which is not the most efficient
% approach in dynamic systems
% PNS reduces lookup latencies by 66\% compared to POK
medium &
% 
medium &
% MaxMind is commercial and cannot be used by FOSS P2P systems. Trying to
% expose information from P2P client can result in security issues.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{CHOord considering Proximity on IPv6 (CHOP6)}
\emph{CHOP6} \cite{MT2007} roughly estimates the proximity among
nodes by exploiting the IPv6 address format and RTT information, if available.
The proximity estimation is achieved by introducing a 64-bit ID scheme in which
the least significant bit part is the IPv6 global routing prefix and thus
enabling a longest prefix match scheme. The protocol is designed based on the
observation that it is possible to estimate a node's geographical location by
simply examining the upper 32-bits of its IPv6 address. Moreover, similar to
Chord\cite{stoica_chord_2001}, CHOP6 uses a finger table, whose entries hold
more than one candidate node.

%
%\paragraph{}
% There are three cases in which a node chooses the next hop according to
% information it possesses.
%\begin{itemize}
% \item When no information about RTT is available candidate next hops, the
%  sender just selects a node in the finger table entry which shares the longest
% prefix with the destination.
% \item There is another possibility that after some communication with other
%  nodes, the source node should know of the RTTs to some of the nodes in finger
% table entry. In this case, the source node chooses the one with the smallest
% RTT with probability $p$. If there is a node with no measured RTT then the
% sender can select such a node with probability $1 - p$
% \item In this last case the source node has already communicated with all
%  candidate node in the finger table entry. Thus, the node selects the node
% whose RTT is the smallest with probability $p$, the one with the second
% smallest with probability $q$ and so on, where $0 \leq \ldots < r < q < p < 1$
% and $p+q+r+\ldots \leq 1$
%\end{itemize}
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Simple approach that exploits proximity but it is coarse grained and thus not
% efficient.
low &
% Its static nature imposes low overhead to the network
low &
% IPv6 is still not widely applied and supported.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{T2MC}
\emph{T2MC} \cite{SLCGZ2008} uses traceroute logs to detect the AS boundaries and
cluster nearby peers together to reduce the redundant multiple message
passes between the AS boundaries. \emph{T2MC} uses a customized k-mean classification
algorithm with $k = 2$ to perform the classification, and exploits the stable
structure of the Internet routers to guide clustering. Even though trace-route
provides detailed information about the network structure, use of trace-route
creates overhead on the overall network structure. For this same reason, it is
not unusual for network administrators to disable this support on their network
routers, which may affect the performance of the \emph{T2MC} algorithm.

The results of T2MC are encouraging but it is also considered coarse-grained
since it classifies peers into only ``remote'' and ``close''
groups \cite{QLZG2009}.


%T2MC \cite{SLCGZ2008} uses trace-route logs to detect different autonomous
%systems and cluster close by peers, thus reducing redundant traffic that crosses
%autonomous system boundaries. T2MC uses a customized k-mean classification
%algorithm with $k=2$ to perform the classification, and exploits the stable
%structure of the Internet routers to guide clustering. The peer chooses the
%minimum and maximum Latency results from the trace-route to initialize the
%centroids of two sets. Then the peer calculates, for all hops along its
%trace-routed path, the peer calculates the absolute distance to these centroids
%of both sets and assigns the routers to that centroid with which it has the
%smaller absolute distance. After that, the mean and variance values are
%calculated and if the variance is larger than a predefined threshold then the
%algorithm sets the two latency mean values as new centroids for the two sets and
%loops again. Ultimately peer will end up with two sets having the minimum
%intra-set variance. The peer, then, chooses the router from the second set with
%the minimum hops attribute and sets it as a threshold. The selected router and
%all others whose hops attribute is larger than the threshold are classified as
%\emph{remote} router cluster. The remaining are classified as \emph{near}. From
%the near class, the peer chooses the one with maximum hops attribute as its edge
%router, and registers it along with all near clusters into the DHT of the
%\p\ overlay. As new peers join the network, those that share the same edge
%router or any of the members of the near router clusters, would form a close
%peer cluster. As Edge routers can provide more valuable information than other
%members of the near set, T2MC was designed to prioritize interaction of peers
%and edge gateways.

%
% TODO: SOME DISCUSSION
%
%The use of Trace-route as a tool for implementing the distance measuring
%infrastructure raise concerns about its efficiency and scalability. Being,
%primarily, a network diagnostic utility,
% Even though trace-route provides detailed information about the network
% structure, its excessive use creates additional overhead that stresses further
% the overall network infrastructure. This forces network administrators to
% disable its support from the routers they manage, thus jeopardizing the
% effectiveness of the T2MC algorithm.
%


\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The efficiency of choosing close by peers is very good and reported almost
% 65\% better than that of GNP (and thus generally of static landmarking as a
% whole)
high &
% trace-route is a very heavy tool and thus incurs excessive burden to the
% network resources.
high &
% Trace-route is categorized as too heavy-weighted and intrusive for use in a
% larger scale system \cite{RKHS2002}. Additionally, disabling
% ICMP is a common administrative policy for edge sites to enforce security,
% while dumping BGP routing tables\cite{krishnamurthy_bgpclust_2000} is not
% directly available to the application layer.
low
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{PChord}
\emph{PChord} \cite{HLYW2005} is based on the Chord DHT and adds
proximity into its routing mechanism. The main modification over the
vanilla Chord, is the inclusion of a \emph{proximity list} into its routing table
so that the next hop is decided based on both the best progress
towards the key and the physical proximity of the candidate nodes.
The list is, at join time, empty but as the \emph{PChord} node starts to interact with
other nodes it applies a heuristic mechanism to fill the list. Entries are
dynamically added or removed as the network state changes. The overlay
maintenance cost is similar to Chord's. Apart from the costs incurred by node
join/leave and by heart-beat messages for connection verification, \emph{PChord} adds
heart-beat among nodes inside the proximity list. Fortunately, since the list
contains nodes with the lowest RTT, the added cost is kept to a minimum.

Due to the fact that, with each step, there is always progress towards the
target node in the ID space, \emph{PChord} will result in a reduced hop number than
Chord, since each hop in \emph{PChord} is larger or at least equal in the key space.
Passing through proximity links, in the underlying network, means reduced routing
cost. Additionally, if the number of entries in the proximity list is the same
as the number of network partitions, \emph{PChord} prevents hops from jumping in and
out of the network partition the current node belongs to.

\emph{PChord}’s advantages include the fact that the main routing optimizations are of
less overlay hops, following proximity links and crossing the same network
partition only once along a routing path while in the same time keeping Chord's
light-weight maintenance cost. On the other hand, it exhibits slow convergence
speed and inefficiency in a high churn environment \cite{DK2006}.

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Small decrease in needed overlay hops per object publishing but rigid in
% high churn environments.
medium &
% The are heartbeat mechanism for both finger table and proximity list adds a
% burden to the network by default. But the overall overhead is decreased as
% the proximity list becomes longer.
medium &
% Improvement of routing is achieved with more object pointers helping to
% shorten the routing path of object querying. When the distance of query source
% to target is far away both Chord and PChord achieve the average hop number to
% not increase.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{AChord}
\emph{AChord} \cite{DK2006} uses IPv6's any-cast mechanism to
relieve the protocol from complex joining procedures, and achieve high accuracy
of network proximity and thus, high routing efficiency. Any-cast delivers a message
coming from the outside of an any-cast group to the physically closest node in
that group \cite{M2002}. \emph{AChord} organizes all nodes participating in the
overlay network into an any-cast group. Any joining node comes outside of that group
and, thus, is
automatically forwarded to the physically nearest node in order to bootstrap,
avoiding the need to, explicitly, maintain such nodes, and the effort of finding
a way of locating the physically nearest among them. The ID of the new-coming
node is computed based on the ID of the bootstrap node and the bootstrap's
predecessor in a way that the constructed ID will be positioned between the
aforementioned two. After joining, the finger table is built the same way as in
the Chord protocol. Moreover, additional nodes are maintained in a structure
called \emph{adjacency table} which stores information about the closest known
node. The routing decision is made by using both the adjacency and finger
tables.

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% good routing efficiency but no adaptation to high churn environments.
medium &
% Relieves the system from joining overhead and topology aware ID construction
% but doubles the information needed to be stored and maintained by the
% introduction of adjacency table
medium &
% assumes the operation of ideal underlying any-cast mechanism (meaning that
% outside messages are always routed to the nearest node which in the current
% Internet, this is not always feasible. Moreover, is designed on the basis of
% IPv6 protocol which is not widely operational yet.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Chord6}
\emph{Chord6} \cite{XZHL2005} is another Chord variant that tries to
exploit the hierarchical features of IPv6 to create a substrate that
reduces inter-domain traffic between service providers. The difference between
\emph{Chord6} and Chord relies on the identifier definition. Therefore, the approach
can be easily portable to other DHTs such as CAN, Pastry and Tapestry. In \emph{Chord6}
the identifier contains two parts: the higher bits are obtained by hashing the
node's IPv6 address prefix of specific length, while the remaining lower bits
are the hash value of the rest of the IPv6 address. As a result of this
assignment, nodes in a domain will be mapped onto a continuous key space on the
overlay network, which avoids unnecessary message forwarding across different
service providers, thus minimizing overall routing cost.

This approach is able to reduce the average path length of the system to be
logarithmically proportional to the number of available domains instead of the
number of participating peers. However due to the large number of Internet
domains and the potentially small number of system peers within each domain,
this approach doesn't seem scalable and efficient \cite{DK2006}.

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Can reduce inter-domain average path length but even though nodes in the same
% domain would have close identifiers, nodes in two close domains may have very
% different ones reducing the overall efficiency of the approach in general when
% considering inter-domain average path length. No active adaptation mechanism
% for high churn environments.
low &
% The construction of the identifier space is done at node join and in an
% independent fashion involving the application of two hash functions meaning
% resulting in low overhead stress to the network and its nodes.
low &
% Is designed on the basis of IPv6 protocol which is not widely operational yet.
low
\end{tabular}
\end{center}

%###############################################################################
%###############################################################################
%###############################################################################
%       PROXIMITY NEIGHBOR SELECTION
%###############################################################################
%###############################################################################
%###############################################################################

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{DHT-PNS}
The work in \cite{DLTZZ2006} propose a proximity neighbor selection
scheme on top of the Chord DHT. The main goal is to use proximity information
to group physically close by nodes as neighbors in the DHT table. In order to
detect proximity, virtual network coordinates of peers are used, by using the
Vivaldi protocol \cite{cox_vivaldi_2004}. The virtual coordinates are then used
by the nodes to map to identifier space in the DHT. The space is partitioned
using a \emph{concentric circle clustering scheme} where successive cycles of
radiuses $\rho$, $2\rho$, $3\rho$ and so on, are constructed. Then the formed
annuluses are divided into $2\chi-1$ \emph{sectors}, where $\chi$ denotes the
sequence number of the annulus starting from $\chi = 1$ for the center cycle. It
is proved in the paper, that this way each sector occupies the same area as does
the center cycle. Assuming uniform node distribution, this characteristic,
favors a more load balanced clustering operation. Every sector in this $2d$
coordinate space is mapped to a unique \emph{region} in the DHT space forming a
multi-layer node identifier space.  Thus, any nodes that belong to the same
sector, are mapped to the same region as well, preserving their proximity
relationship unveiled by the use of the Vivaldi protocol. The individual pieces
are mapped to the identifier space uniquely, allowing logarithmic lookup
operations with high probability on Chord. The system described in the previous
section allows any node to obtain its DHT key and its region key, in a fully
distributed manner, just by applying a consistent hash function. Using an RPC
call in Chord, the node can obtain the region's master node, called
\emph{Cluster Node (CN)} which is responsible for clustering the nodes belonging
in the same sector or region with that of the node at hand. An additional RPC
call, registers it to its corresponding region and publishes its information,
through the special peer CN. The node can, additionally, ask CN for other
nodes that have previously joined the region to add them into its
neighbor set for future routing table optimization. Even in the case when no
neighbor is detected in the current region, the search is expanded to adjacent
regions and towards an upper layer identifier space until one is found or the
first layer reached. Simulations suggest that the scheme has good convergence
property of the delay distribution and good optimizing performance.
Unfortunately, even though scaling seems to be also smooth, the simulations
where made on rather small test beds (of at most 2048 nodes), so no safe
conclusions can be deduced. Moreover it assumes uniform node distribution which
is not always the case, especially in a synthetic coordinate system.\\

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
%
medium &
%
medium &
%
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Quasi-Chord}
In \cite{SZ2008} proposes \emph{Quasi-Chord}, a Chord-based network that
constructs its overlay network with underlying topology in mind. The network
construction follows three steps. First, each host acquires its coordinates in
the geometric space utilizing the \emph{global network position (GNP)} protocol
\cite{ng_gnp_2001} and a set of landmarks.
Second, using the \emph{Cantor space filling curve}, the $2$-dimensional space
is converted to a $1$-dimensional one, used in the last, third, step to build
the \emph{Quasi-Chord} circle according to the host's Cantor value. Physical
proximity is thus denoted by Cantor value proximity. The Chord cycle is
constructed by sorting nodes in ascending order. In \emph{Quasi-Chord}
each node stores 2 finger tables; one clockwise and one counter-clockwise.

%In the following paragraphs, these steps are further discussed.
%
%\paragraph{GNP coordinates}
%First of all the host must be positioned in the geometric space. The algorithm
%  models the \p\ network with a well defined distance function in such a way,
% it can predict, with high accuracy, the distance between any two points in the
% space by just evaluating the output of the distance function on the
% coordinates of these points. This is accomplished with the \emph{global
% network position (GNP)} protocol which\begin{inparaenum}[\itshape i\upshape)]
%  \item creates a reference set of $N$ landmark nodes so as to minimize the
%  error of ICMP measured distances and coordinate computed ones between them,
% and then
%  \item each host is able to measure its round-trip times to the $N$ Landmarks
% in order to compute its own coordinates.
%\end{inparaenum}
%
%\paragraph{Cantor SPF}
%After the $2$-d coordinates are set, in the next stage of the algorithm, each
%  participating peer is assigned a Cantor value, according to the application
% of a \emph{space filling curve} on the coordinate space. (TODO: add figure).
% This results in the conversion of the $2$-dimensional space to a
% $1$-dimensional Cantor space that can more easily be more mapped to the Chord
% hierarchy.
%
%\paragraph{Quasi-Chord construction}
%As can intuitively be inferred by observing the Cantor chart, close-by nodes in
%  the physical layer, are more likely to have similar Cantor values. This
% attribute is exploited in order to construct a topology-aware identifier space
% for the Chord DHT. The cycle is constructed by sorting nodes in ascending
% order. Each host maintains 2 finger tables, one for clockwise and one for
% counter-clockwise stepping. This helps with the connectivity of the network
% because its not allowed to connect the first node with the last one since this
% will incur heavy traffic to the later\footnote{After all their Cantor values
% denote that they are actually the furthest of each other.}.
%

%
% TODO: SOME DISCUSSION
%       NEEDS DOUBLE-CHECK
%
%The disadvantage of the algorithm is that the coordinate assignment in the
%  first stage is backed by a not fully distributed landmark-based algorithm.
% Moreover the Quasi-Chord model build-up is making an indirect assumption of a
% maximum number of allowable hosts since it is constructed. Last but not least
% the doubling of the required routing information which needs to be created and
% maintained is an additional negative point to the efficiency and the
% scalability of the algorithm.
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The algorithm shows to reduce end-to-end delay as well as not produce
% duplicates of messages.
medium &
% The overhead is more compared to vanilla chord since mapping of 2-dimensional
% space to 1-dimensional with Cantor SPF adds some extra burden in time
% complexity. Also the addition of the counter-clockwise finger table doubles
% the data, per se, needed to be stored and maintained.
high &
% The GNP system is a static landmark approach making things not fully
% distributed and thus constrain the model's scalability.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{IP-based Clustering (IPBC)}
Proximity neighbor selection algorithms use probing and other techniques to
detect proximity. However, such methods are either not precise enough, or
overload the network. \emph{IP-based clustering} \cite{KM2007} is a proximity
neighbor selection based algorithm which uses the IP address prefixes (16 bit
for IPv4) in order to detect proximity. \emph{IPBC} clustering generates a key
and its prefix and stores the prefix in the DHT itself, so that any newly
joining nodes with the same IP prefix can query it and
identify all the neighbors with the same prefix easily.  Nodes
periodically update their entries in the DHT by removing those who leave, or
those who have been timed-out.

The algorithm's overhead is very low because detection of proximity is only
a comparison of prefixes. On the other hand, the efficiency of the proximity
is caught into a vicious cycle with the storage space needed for DHT object
publishing (how many bits will be used for either). Moreover, its static
nature (no online measurements used) makes it difficult to handle
\cite{EWF2011}.

% Moreover, observing the
% \emph{IANA IPv4 Address Space Registry} we can infer that, since blocks of
% consecutive octet prefixes are assigned to the same Regional Internet
% Registries (RIRs), nodes inside will be physically close to each other.

%
% In order to be published in the overlay, each node is first assigned a
% unique identifier and subsequently generates a key by hashing a fixed-length
% prefix of its IP. Authors argue on the prefix length to be used, as there is a
% thin balance between reducing the probability of finding closer nodes by
% adopting a long prefix and overload nodes that are responsible for information
% published by many peers when choosing to hash a short one. Their verdict is
% for
% the use of a 16-bit wide prefix for real world systems deployed in an Internet
% scale. In either case, ID and IP is then stored in the DHT using this
% generated key. This way, any node, at any time (either at join time or during
% peer lifetime for topology adaptation) can acquire information about close-by
% nodes just by querying the DHT for a specific key. Moreover, the algorithm
% takes care of the freshness of the proximity information in two ways. First,
% the advertising nodes themselves periodically update their advertisements or
% when they voluntarily leave the overlay, they explicitly remove their data. On
% the other hand, in case of a failure each publication is assigned an
% expiration time, and thus ultimately removed by the DHT maintenance
%mechanisms.
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The efficiency of proximity detection through the prefix matching technique
% is caught in a vicious cycle with the storage space needed for DHT object
% publishing (how many bits will be used for either).
low &
% The overhead for detecting proximity is only comparison of prefixes
low &
%
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Cone}
\emph{Cone} \cite{HY2007} extends Chord using a proximity neighbor
selection topology optimization algorithm. The proximity information is
generated using landmarks and round-trip-time-based distances to landmarks.
\emph{Cone} uses a two-layered identifier space. The first, named Chord-layer
identifier, denoted as $Id_{Chord}$, is the same as in Chord. The second is the
Cone-layer identifier, $Id_{Cone}$ which is constructed using two component
identifiers. The first, known as \emph{group identifier (gid)} denotes a
relevant group to which the node belongs while the second, namely \emph{local
identifier (lid)} indicates the local identifier within the group. The group
concept is a way of dividing nodes according to a
common $Id_{Chord}$ prefix.  The structure of a Cone overlay, retains the
Chord's circular topology. The difference lies in the fact that, now, two rings
are created. A big ring, where nodes with the same \emph{gid} are arranged at
each position. Each of these positions are a smaller ring for the particular
group's \emph{lid}s. Routing is achieved in both clockwise and
counter-clockwise directions in the big-ring, for which two routing tables are
maintained, namely \emph{front} and \emph{back} finger tables. Entries in these
tables, display physical network proximity with the current node. Moreover, a
third table called \emph{group} maintains information about other on-line peers
within the current node's group in a way that entries are now close in the id
space.

%
%Routing in Cone, comprises of the inter-group algorithm and the intra-group
%  algorithm. First the group of nodes to which the desired key lies is
% detected, exploiting physical proximity information (front and back finger
% tables). Second during the next and last hop, the message is forwarded to the
% exact node that contains the desired key.
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The result of experiments show that the Cone, compared with Chord, has obvious
% improved on the delay of route and the hops of overlay networks…
medium &
% The approach incorporates a static landmark + RTT to these landmarks in order
% to exploit proximity information thus incurring low overall additional
% operational overhead but imposing extra stress to the landmarks themselves.
% Additional information must be maintained, three finger tables (front, back and
% group)
medium &
% landmark based approaches are not full distributed thus not smoothly scalable.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{DynaMO}
\emph{DynaMO} \cite{WZS2004} tries to build an overlay that not only 
considers physical proximity amongst peers but their mobility attributes as well.
To adapt to mobile, ad-hoc networks, special care is put in by \emph{DynaMO}
to maintain an evenly distributed overlay ID space so that hot-spots are
avoided. The paper's implementation is based on the Pastry overlay due to its
built-in locality heuristics that have been extensively studied
\cite{CDCR2002a} but \emph{DynaMO}'s mechanisms are DHT-independent so it can be
applied to other DHT's.

\emph{DynaMO}'s approach can be viewed bottom-up. A new-coming node is required
to compute physical information about its neighborhood and use it to
unilaterally assign itself the an ID. \emph{DynaMO} is building on the
observation that with every new overlay routing hop the physical distance
between nodes is likely to increase, resulting in a dominating last routing
step \cite{antony_pastry_2001,CDCR2002a} and for this two methods are discussed,
\emph{random landmarking (RLM)} and \emph{closest neighbor prefix assignment
(CNPA)}.
%%
In \emph{RLM} a set of peers are chosen to be responsible for a set of landmark
keys. These keys have to be chosen in a way that they equally divide the overlay
space. The new-coming peer then computes distances to those
landmarks, sorts them and assigns itself an ID based on the landmark ordering.
In more detail, the peer adopts an ID prefix of length
$prefix_length=|log_b k|$ (where $b$ is the ID base and $k$ the number of
landmarks) from the landmark closest it and the rest can be assigned either
randomly or computed with further proximity optimization in mind.
What is achieved is that
\begin{inparaenum}[\itshape i\upshape)]
  \item landmark assignment is dynamic, and
  \item a node’s leaf set is likely to reference physically close nodes.
\end{inparaenum}
Especially, the latter observation reduces the average routing cost because the
leaf set is utilized for the last routing step (since it contains the nodes
closest in the overlay space).
%%
\emph{CNPA} is proposed for network setups that want the bootstrap phase as lightweight
as possible. It delegates to Pastry, the burden to identify the physically
close node with which the new-coming peer will bootstrap. The new-comer assumes
the bootstrapping nodes's ID prefix and fills the rest like \emph{RLM} does.

\emph{RLM} achieves good proximity evaluation in a load balanced and adaptable to
high churn environments fashion. Unfortunately it comes with more bootstrap
overhead that can especially effect the set of temporary landmarks. On the other
hand, \emph{CNPA}'s less incurred overhead comes at the expense of being more
coarse-grained.

% \emph{DynaMO} tries to capitalize on the fact that in Pastry each node's table consists
% of rows equal to the number of digits in the overlay ID and columns equal to
% the ID's base. As we go down the table rows, the matching prefix between the
% current node's ID and the row's entries increases by one. Thus, the leaf set
% contains the closest nodes in the ID space. Additionally, as the prefix match
% increases by one, the result is exponentially fewer candidates that can fill the
% tables entries as the row increases. This leads to the observation
%  In this context, two approaches are considered namely
% \emph{Random Landmarking (RLM)} and \emph{Closest Neighbor Prefix Assignment
% (CNPA)}.


%
% TODO: SOME DISCUSSION
%
%Both algorithms, are protected against the formation of physical landmark
%  clusters or imbalanced ID distribution\footnote{More common during the
% initial formation of an overlay network} , by introducing the \emph{landmark
% gravitation range} as a threshold over which landmark keys are reassigned (for
% the RLM approach) or unutilized ID prefix ranges are detected and used (for
% the CPNA scheme) in order to balance the distribution of regions in the
% overlay.
%

\begin{center}
{\footnotesize
\begin{tabular}{rccc}
\multicolumn{1}{r}{} &
\multicolumn{1}{c}{\emph{Efficiency}} &
\multicolumn{1}{c}{\emph{Overhead}} &
\multicolumn{1}{c}{\emph{Scalability}}
\\
\cline{2-4}
\emph{RLM} &
%%
%% TAKEN FROM
%% Efficient service discovery mechanism for wireless sensor networks
%%
%%
% common prefix of the overlay ID with the closest landmark. The
% RLM utilizes the overlay lookup capabilities by reducing traffic
% overhead within an overlay cluster. However, it generates much
% control traffic for periodically measuring distances to all landmarks.
% Moreover, the hop stretch overhead still increases when
% performing overlay routing among overlay clusters.
medium &
%
medium &
% Dynamic landmarking approach helps the scalability of the algorithm. The
% authors claim that the temporary nature of RLM's landmark nodes does not
% prevent them to maintain a good ratio in the presence of high landmark
% degression rates.
high \\
\emph{CNPA} &
%
medium &
% % The paper suggests that this approach generates significantly lower overhead
% than the vanilla Pastry algorithm
low &
% The queries are directed through fast nodes so it is important such nodes
% be part of the network
medium \\
\end{tabular}
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{SAT-Match: Self-Adaptive Topology Matching}
% \begin{figure}[ht]
% \centering
% \subfigure[Example physical topology of nodes.] {
%   \includegraphics[scale=0.6]{img/algorithms/SAT_match}
%   \label{figure:sat_match:before}
% }\qquad\qquad
% \subfigure[(left) A jumps to B in order to match the logical topology to the
% physical. (right) State of the logical topology after the jump.] {
%   \includegraphics[scale=0.6]{img/algorithms/SAT_match2}
%   \label{figure:sat_match:after}
% }
% \caption{The SAT-Match algorithm.}
% \label{figure:sat_match}
% \end{figure}

\emph{SAT-Match} \cite{RGJZ2004} defines an iterative process that attempts to
adaptively change the overlay network to ease the topology mismatch problem. It
consists of a \emph{probing phase} when a peer probes nearby nodes for distances
and a \emph{jumping phase} when the peer decides to change neighborhood to
reduce its average neighbor distances. This process is performed unilaterally
until no additional optimization is needed but it achieves optimization within a
sufficiently large scope.
%% VM This is used in other papers. Maybe we can put somewhere in the
% definition of Topology Mismatch Problem in the intro/background.
The paper defines \emph{stretch}
$S = \frac{\bar{L_l}}{\bar{L_p}}$, where $\bar{L_l}$ is the average logical link
latency while the $\bar{L_p}$ is the average physical link latency, and uses it
a way to quantify the \emph{topology match degree} of the constructed overlay.

The \emph{probing phase} starts when the new-comer joins the DHT using the
standard mechanism of the algorithm at hand. The starts probing the neighborhood
the messages of small TTL value $k$ \cite{jiang_lightflood_2008}. Recipients return
information to the source and forward the message if not expired. After
discovering its TTL-$k$ neighborhood, the source measures RTT times, sorts them
and picks the two nodes with the smallest RTTs.

In the \emph{jumping phase}, the source node calculates the stretch change of
its $TTL-1$ neighborhood and that of the $TTL-1$ neighborhood of the first of
the peers picked during the previous phase. These calculations are made as if
the jump has been made. If the stretch reduction is over a predefined threshold
the jump is performed, otherwise the second selected candidate is picked and the
same computations are performed. If again, the threshold is not met, then no
jump is ultimately done. In case of a jump, this is performed as a combination
of \emph{leave} and \emph{join} operations, in the underlying context
(i.e. CAN).

Even though no theoretical proof is given, valid results are
obtained and demonstrated through experimentations. It is argued that since it
is observed to achieve a $27\%$ stretch reduction when compared to a landmark
enhanced CAN-system, it can be deduced that it performs better than landmark
binning in terms of the matching degree.

% Figure~\ref{figure:sat_match} demonstrates the selective jump on an
% example topology.

%
%\paragraph{}
%Moreover the algorithm takes several issues into consideration in order to
%  further improve the resulted overlay. For example when multiple nodes try
% to jump simultaneously into a region, then the logical link brakes from one
% attempt may result in inaccurate computation of the gain factor, for an other.
% This situation is identified as \emph{contention} and the nodes use an
% exponential back-off algorithm to avoid it. An other problem is the
%unnecessary
% traffic incurred by the probing phase in a region that after several jumps
% has settled to a stable state. In these cases it is more likely for jump
% attempts to be proven worthless. The algorithm doubles the probing period of
% such nodes, every time a jump is not taken.
%
%\paragraph{}
%The authors claim that this continuously adaptive mechanism achieves global
%  topology matching optimization in a sufficiently large scope. This also
% secures the fast adaptation to frequent network changes. It also considered
% lightweight and can easily be embedded into current \p\ systems, as well
% as effectively combined with other techniques, such as landmark binning.

%
% TODO: SOME DISCUSSION
%
% It is reported that,
% due to the selective jumps, SAT-Match achieves $40\%$ reduction in
% link stretch, and when used with the landmark binning (see
% Sec. \ref{sec:landmark_binning}), the reduction rate increases up to $60\%$.
% For dynamic environments, with frequent node arrival and leave, SAT-Match
% scales much better than Mithos, due to its self adaptation mechanism and
% selective jumps.

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% SAT-Match seems to outperform landmark binning in the sense of providing a
% higher grained differentiation of proximity, adding to the fact that
% SAT-match is fully distributed. Also to further enhance the efficiency it can
% work cooperatively with landmark binning itself.
% Security is compromised with arbitrary jumps!
high &
% distance probing and iterative computations add to the approach's overhead.
% Also the fact that the selective jumps are not always performed the added
% overhead to efficiency gained is not guaranteed in any configuration and
% circumstance.
medium &
% The self-adaptation nature of the algorithm and the selective jump mechanisms
% scale much better than, for example, Mithos. The test are on a relatively
% small amount of peers, thus, no safe conclusion can be made with respect to the
% algorithm's scalling performance.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discussion on the Algorithms for Structured Architectures}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% VM I commented out the following paragraph since it feels out of place
% (maybe better in the intro or background) or duplicated (from the intro or
% background).
%% 
% Structured \p\ network algorithms use a global distributed hash table or a
% prefix tree structure to uniquely lookup peers or their data in the overlay
% network. As all the data is kept within the overlay, each node behaves as a
% client and a server, therefore nodes join and leave according to rules
% determined by the integrity of the global data structure. The main advantage of
% the structured \p\ topology is that with the help of the global data structure,
% peers or their data can be found within the network even if there is only a
% single copy of that item present. However, each node join and leave creates
% maintenance overhead for the network due to updates required by the global data
% structure, and for networks with frequent node arrivals and departures, the
% overlay uses valuable network resources just to update the global structure.
% Nodes join the network by using a key value, which determines the location and
% the neighborhood of the new node within the network. However, assigning
% random key values to the newly inserted nodes creates non-optimal matching with
% the underlying physical network topology, therefore, increasing the overhead of
% the network even more. One solution for handling the topology mismatch problem
% is to consider the proximity of the peers when generating the key and joining
% the node to the network, so that nodes within the same network domains are
% selected as peers, or neighbors, during the overlay topology construction.

This section gathered together some of the most distinctive research work that
can be found in the literature for addressing the inefficient network resource
utilization in structured architectures imposed by the topology mismatch
problem. A categorization of the methods used for achieving their goals is the
following based on previous work from
\cite{CDHR2002,CDCR2002,RSS2002}:
\begin{enumerate}[\itshape i\upshape)]
  \item geographic-layout-based,
  \item proximity-routing-based,
  \item proximity neighbor selection based,
\end{enumerate}

%%VM Added the following to mention the hybrid/combo methodologies
Similarly to unstructured approaches, most of the reviewed structured ones,
incorporate multiple of the above methodologies. For example, \cite{KLKP2008}
uses both proximity routing and proximity neighbor selection and achieves
topology adaptation, or \emph{LAPTOP} combines geographic layout with
replication strategies to refine the end results. The heuristic nature
of the proposed solutions makes it a game of trade-offs, that in most cases
is highly affected by the application domain and the implementation itself.
Thus, the reader is advised to filter the results of each approach and try to
think about how the points presented will work in her own particular problem.

A quick overview can be obtained in Table~\ref{structured:table}. Topology
adaptation, landmarking and caching/replication have been visited during the
discussion on unstructured systems in Section~\ref{section:unstructured} so
we will not elaborate more here. As in the previous section, we provide the
key properties of each algorithm that differentiate it from the others and
highlight each algorithm's advantages and disadvantages.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Geographic layout} \label{section:geographic_layout}

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.4]{img/pdf/geographic-layout.pdf}
\caption{Successive nodes in the overlay circle can be chosen to be from the
same or near autonomous systems.}
\label{figure:geographic-layout}
\end{figure}

In the \emph{geographic layout (GL)} category fall methods which practically
position physically nearby nodes together in the application space as well
(check Figure~\ref{figure:geographic-layout}). This is done by adjusting and
maintaining the routing tables of all involved peers by exploiting
proximity information that describe the overall geographic positioning of the
peer nodes. Some of the algorithms we saw were \emph{Global Soft-State},
\emph{Mithos} and \emph{LAPTOP} which all try clustering close by nodes in
order to reduce the network's average delay.
Landmark servers and RTT measurements are two popular methods, which
can also be used in conjunction, to discover physically nearby peers over the
network. However, as already discussed, these
methods do not always give reliable estimates for the node positions over the
Internet. The landmark servers are not self-organizing and have maintenance
overheads. To serve a \p\ network with millions of peers, multiple landmark
servers distributed over the whole world is required, which is hard to manage.
The RTT measurements also can measure the delay between peers, but it is a
greedy method, which can result in non-optimal overlay topologies especially if
close by nodes have low bandwidth connections among themselves.

Even though managing the overlay structure based on the \emph{GL} of the
nodes improves the query efficiency of the system, on the other hand, it tends
to undermine the uniform distribution of peer identifiers which consequently
tend to create hot-spots, failing resilience is undermined by the fact
that nearby nodes are more likely to suffer collective failures \cite{HY2007}.

% must
% cope with the inherent trade os associated with selecting
% identiers based on location: randomly selected identiers
% are essential for the scalability and security of the system
% and help to balance load while location-aware identiers pre-
% vent messages from taking extensive scenic routes (on the
% physical level). 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% TODO: Geographic Layout
%
%\begin{itemize}
% \item Geographic Layout\\
%The node IDs are assigned in such a way that nodes close by in the physical
%network topology, be close in the node ID space as well. Implementations that
%work relatively well with this approach have been incorporated into CAN. Nodes
%measure the RTT between themselves and a set of landmarks in order to match the
%CAN space as much as possible to the physical one. Unfortunately, the approach
%requires well known landmark servers and for that matter is  not fully
%self-organizing which can further lead to imbalanced node distribution. On
%other DHTs, such as Chord or Pastry, another problem emerges.  To gain fault
%tolerant properties, these protocols, replicate key-value pairs on neighboring
%(in the ID space) nodes. When a proximity-based node ID assignment has been
%used, the needed failure resilience is undermined by the fact that close by
%nodes are more likely to suffer collective failures.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Proximity Routing}

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.4]{img/pdf/proximity-routing.pdf}
\caption{Proximity routing takes proximity information into account during the
routing process.}
\label{figure:proximity-routing}
\end{figure}

\emph{Proximity routing (PR)} does not require routing tables to be built using any
knowledge about network proximity. On the other hand it exploits such knowledge
to choose the best next hop when routing a message as can be seen in
Figure~\ref{figure:proximity-routing}. We visited an array of methodologies that
implemented this method, either on its own like in \emph{Mithos} and
\emph{PChord} or in conjunction with proximity neighbor selection like in
\emph{DynaMO}. \emph{PR} tries to balance between choosing the node that will
further progress the routing towards the destination and choosing the closest
entry in the routing table, in terms of network proximity. As this is very
difficult to achieve, the system might end up
using a greedy approach that selects low latency paths on the overlay, which
maps to suboptimal longer paths on the physical topology. Thus, in general,
proximity neighbor selection is considered as a superior method to proximity
routing, however, joint uses of these two protocols are also possible. Moreover,
they are less effective than geographical layout when applied to CAN(-like)
implementations.


% Moreover, the technique has been
% incorporated into a version of Chord causing an increase in the overhead of node
% joins and the size as well as maintenance cost of finger tables.

%
%\cite{dabek_cfs_2001} proposes a server selection scheme for the Chord DHT, on
%the domain of proximity routing selection. In \emph{CFS}, each node predicts
%the entire lookup latency as a function of the total number of nodes and the
%average overlay next routing peer. The problem is that it is very difficult to
%have a clear picture on the total number of nodes and the average hop latency
%from the local. This leads to rough estimations that consequently decreases
%overall performance.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Proximity neighbor selection}

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.4]{img/pdf/proximity-neighbor-selection.pdf}
\caption{Proximity neighbor selection dictates that proximity is taken into
account during routing table maintenance.}
\label{figure:proximity-neighbour-selection}
\end{figure}

\emph{Proximity Neighbor Selection (PNS)} constructs the routing tables using
proximity knowledge (see Figure~\ref{figure:proximity-neighbour-selection}). The
proximity information used in this method is different from the the
landmark-based systems described in Section~\ref{section:geographic_layout}.
Here time-to-live values between nodes (i.e. \emph{SAT-Match}) or IP address
prefixes (i.e. \emph{DynaMO} or \emph{Cone}) are used to detect
proximity. \cite{freedman_iploc_2005} states that $97\%$ of prefixes larger
than $24$ bits belong to a single geographical location. However, using a
smaller number of bits creates less precise results and a larger number of bits
increases the burden on the network and reduces the possible number of
neighbors. Moreover, in \cite{HLYW2005} it is argued that such approaches can
destroy the uniform distribution in the key space and do not work in
one-dimensional key space where the mapping is constrained on the overlay layer.
Therefore, a careful selection is required in terms of
performance/accuracy trade-off. Tapestry, Pastry, and CAN successfully incorporated
proximity neighbor selection into their algorithms. The routing protocol in
Pastry is based on longest node ID prefix matching, while CAN uses RTT values to
detect nearby nodes. \cite{CDCR2002a} reports that proximity neighbor
selection is an effective proximity based method.


% \item Proximity Neighbor Selection\\
%Finally, the third approach, constructs the routing tables using proximity
%knowledge. Tapestry and Pastry's mechanisms of routing table
%maintenance try to minimize the distance to nodes appearing in a peer's routing
%table. Since routing is based on longest node ID prefix match, messages
%are gradually forwarded to nearby nodes at each routing step.
%\cite{castro_proximityp2p_2002} argues on how Pastry exploits proximity
%neighbor selection in order to create a scheme that is (more) location-aware
%compared to the other well-known DHTs (CAN, Chord).
%
%\end{itemize}
%
%{\sethlcolor{yellow}\hl{
%HA: Possible criteria: based on which protocol (eg Gnutella, CAN etc), peer
%selection (topology selection, cluster, cache etc), supports dynamic update,
%runtimes}}
%%\textbf{Algorithm} & \textbf{Overlay structure} & \textbf{Forwarding} &
%\textbf{Cache} & \textbf{Overlay optimization} & \textbf{Proximity information}
%& \textbf{Base protocol} & \textbf{Dynamic update} & \textbf{Runtime} \\
%
%
%{\sethlcolor{yellow}\hl{
%HA: Possible criteria2: Overlay optimization structure, base protocol (eg
%Gnutella, CAN etc), dynamic update, runtimes, scalability}}
%
%{\sethlcolor{yellow}\hl{
%HA: maybe add also the year of publication, and see if there is a pattern in
%terms of the method and the year??}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{structured-table}

\input{structured-plot}
