\section{Structured \p\ Networks}
\label{section:structured}

This section offers description and analysis of algorithms proposed
to address the topology mismatch problem in structured \p\ networks. 
The categorization of the approaches is based on how different
levels of proximity information is gathered as well as  
the way peer routing tables are maintained and used in an effort make hops in
overlays as efficient as possible. 
%%AD what does it really mean this below???
The categorization is based on previous work found in the
literature~\cite{CDHR2002,CDCR2002,RSS2002}.

%%COMM Rephrased as above to keep it analogous to the opening paragraph of
%% the unstructured part.
%%
% This section presents a description and analysis of algorithms proposed
% to address the topology mismatch problem in structured \p\ networks.
% In structured \p\ networks, the construction of the routing tables
% held by participating nodes determines the efficiency of message forwarding.
% Routing tables that closely match the underlying IP topology
% achieve increased performance. As a result, the proposed solutions for
% the topology mismatch problem for structured \p\ networks
% use different levels of proximity
% information to optimize the routing tables used by peers.
% The categorization of the algorithms we present here is based on the
% categorization suggested by previous
% work~\cite{CDHR2002,CDCR2002,RSS2002}.

\subsection{Algorithms for Structured Architectures}

%###############################################################################
%###############################################################################
%###############################################################################
%       GEOGRAPHIC LAYOUT
%###############################################################################
%###############################################################################
%###############################################################################

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Global Soft-State}

% \begin{figure*}
% \centering
%   \includegraphics[scale=0.8]{img/algorithms/global_softstate}
% \caption{(left) Position of $p$ in the space of $3$ landmarks. (right) Position
% of $p$ on the map.}
% \label{fig:global_softstate}
% \end{figure*}

\emph{Global Soft-State} \cite{XTZ2003} builds a global map to help
choose shorter routing paths. This is accomplished by 
combining the landmark binning method with small
scale distance probes to reveal the proximity properties 
of the underlying network. 
%Figure \ref{fig:global_softstate} presents the landmark
%space and the mapping of the position of the nodes.
This global view of the state is made available to 
\emph{all} nodes to help them find the best way to route their messages. 
%%AD when you say "all" above means what?? all in the structured network?? 
%%	how is the structured network organized?  (a line or 2 for this?)
\emph{Global Soft-State} operates in $2$ phases:
\emph{generation} and \emph{use} of the proximity information. 
For \emph{generating} the proximity information, 
a hybrid approach is proposed: it uses landmark clustering as a
preprocessing step to select a number of potential nearest neighbor
candidates and then, refines the selection by incorporating a
round-trip-time-based scheme to ultimately choose the closest node. 
%% 
The algorithm follows a different path from that of the
classic gossiping approaches for the construction and 
maintenance of the overlay when 
it comes to \emph{use} the proximity information.
%%AD isn't the following sentence somewhat of repetition??? (of what 
%%	is stated above?? 
The approach is based on landmark clustering 
for generation and strategic
placement of proximity information on the overlay. 
This information is called a ``map'' and concerns a 
region of the overlay; 
the latter may be part of the Cartesian space in
structures like \emph{eCAN}~\cite{xu_ecan_2002} or 
a set of nodes sharing a particular
prefix in overlays such as \emph{Pastry}\cite{antony_pastry_2001}. 
%%
Thus, each node not only can access such information from 
these landmarks but can also subscribe to
relevant \emph{soft states} and get notified on dynamic network changes. 
A node may appear in a maximum of $log(N)$ such maps.
%%
Although this approach does reduce the routing latency to far nodes, it
can become expensive as it is 
possible to end up with a very large number of regions
each of which has to maintain a map. 
The fact that a peer may appear in multiple
such maps points into additional traffic for probing and notifications
and so renders the approach not scalable \cite{RGJZ2004}. 
Moreover, to refine measurements
additional inner-bin measurements are needed~\cite{WZS2004}.
Also, improvements within a region can be minimal as there exists
limited knowledge about neighboring zones.
%%AD rephrased what is below -2 lines- as above..
% Also improvement
% is done within a region because of little knowledge about neighboring zones.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% COMM Removed most of the paragraph below which 
%%		contains info that we cannot back
%%
%% Rescanned papers and wrote the paragraph below.
%% DO NOT PERMANENTLY DELETE!
%%
% Unfortunately, maintained of several host states at different layers,
% renders any content migration a costly process. Additionally, the method does
% not make any continuing effort to remap
% the overlay structure after nodes successfully join resulting into poor
% adaptation to changing conditions. Although this approach greatly reduces the
% routing latency to far nodes, it is unable to dynamically identify nodes that
% are close to routers and gateways in order to construct the secondary overlay.
% Nevertheless, static recognition of such nodes is currently done based on BGP
% reports and pre-chosen landmarks, sacrificing the self-organizing attribute of
% traditional DHTs.
%
%
% TODO: SOME DISCUSSION
%
% Xu \textit{et al.} \cite{XTZ2003} state that there are three ways
% generating proximity information
%\begin{itemize}
% \item Expanding Ring Search\\
%Expanding ring search can be of two forms. First it can utilize the multi-cast
%infrastructure in the underlying network in order to emit its messages.
%Unfortunately such infrastructures are not widely deployed thus the
%implementations of this way of generating proximity information is limited to
%blindly flooding the neighborhood to obtain reasonable results.
%
% \item Heuristics\\
%Heuristics are used in order to reduce the blindness of the expanding ring
%search and make realizations more efficient and effective. Unfortunately a
%common problem of all heuristic approaches is the local minimum pitfall in
%which
%the search might be caught into.
%
% \item Landmark Binning\\
%Landmark clustering is based on the view that nodes with similar distances to a
%set of predefined well-known landmark nodes are pretty likely of being close to
%each other. But this approach has its weaknesses as well, such as the fact that
%is a rather coarse grained approximation, therefore not particularly well
%suited
%for differentiating nodes within close distance to each other.
%
%\end{itemize}
%
%
%
% TODO: IN PAPER INTRODUCTION A DISCUSSION ABOUT
%TOPOLOGY-AWARE CAN
%
%Techniques to exploit topology information in overlay
%routing include geographic layout, proximity routing and
%proximity neighbor selection [3]. With geographic layout
%such as topology-aware CAN [12], the overlay structure is
%constrained by underlying network topology. This tech-
%nique, unfortunately, can create uneven distribution of
%nodes in the overlay, increasing the chances of overloading
%nodes and rendering the maintenance cost formidable. Our
%study shows that, for a typical 10,000-node topology-aware
%CAN, 5% nodes occupy 85-98% of the entire Cartesian
%space, and some nodes have to maintain 450-1500 neigh-
%bors. In Proximity routing, physical topology is not consid-
%ered when constructing the overlay.
%
In terms of our $3$ criteria, the approach fares as follows:
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Unable to identify nodes that are close to routers but it can reduce routing
% latency to far away node by approximately 50-75%.
medium &
% maintenance of node states, subscriptions and notifications need global
% overview of the overlay resulting in high control overhead
high &
% Statically implemented sacrificing the decentralized nature of DHTs and
% thus poorly scaling. Also we can end up with a very large number of regions.
% Because of the fact that a peer may appear in multiple
% such maps we can conclude that additional traffic for probing and notifications
% renders the approach does not scalable.
low
\end{tabular}
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Mithos}
\emph{Mithos} \cite{WR2003} is a \p\ protocol which incorporates directed
incremental probing to find near optimal node placement and integrates
geographic layout and proximity routing overlay optimization methods.
%%AD in general some mention of the mismatch problem must be made right???
%%		so that a reasonable connection can be established... 

The bootstrap phase of \emph{Mithos} starts with a subset 
of existing members as the initial set of candidates and 
while the closest nodes are detected by iterative
probing of the neighborhood, the candidate neighbor--list gets updated. 
To avoid local minima, \emph{Mithos} probes all the neighbors 
within a two-hop distance from the current minimum 
before concluding the process.

After finding its first neighbor, an 
% new-coming   %%AD overall the term new-coming is somewhat odd.. incoming? 
incoming peer is assigned 
an \emph{ID} using information gathered during 
the iterative neighbor selection phase. 
%%AD use SIMPLE sentences that are well structured to say what u want
Based on the two closest nodes found, along with these nodes neighbors and the corresponding
distances a system of virtual springs is set so that the tension of each spring
is inversely proportional to the distance. 
%%AD the above is impossible to read.. "based on,... along with... " NO!!!
%%AD I am not sure what you are talking about here - I mean below... rework
%%	and simplify.. 
The system is then left to settle,
and the state in which it settles is used for its \emph{ID}. 
The benefit of these synthetic coordinates are that
they are explicitly used as the node's \emph{ID}, 
and distance computations among nodes
can be done in \emph{ID} space without requiring physical measurements.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% upto here %%%%%%%%%%%%%%%%

The last step of the algorithm is the 
interconnection among neighbors. 
\emph{Mithos} uses a \emph{quadrant-based} mechanism in which 
each node establishes a link to the closest neighbor in each quadrant. 
%%AD what is the quadrant??? Hugh??? 
During forwarding, the next hop is performed towards a neighbor 
in the same quadrant of the final destination. 
An incoming node may not know of other neighbors in all
quadrants, therefore, the node first identifies neighbors in all quadrants
using a mechanism based on ideas similar to a perimeter walk~\footnote{Used in
the Greedy Perimeter Stateless Routing (\emph{GPSR}) protocol.}  %%AD ref??
and then improves the results using parallel path processing 
by taking into account further geometric properties of node relationships.
%%AD the above 5-6 lines sounds impressive but there is little help 
%%	for the average ignorant reader.. what is perimeter walk in 
%%	general? how quadrants are formed? What is their relationship? 

One major limitation of \emph{Mithos} is that the protocol cannot effectively
handle dynamic arrivals and departures from the network. 
\cite{CCRK2004}~points out the extensive probing to determine 
distances and evaluates \emph{Mithos} results as less accurate
than those derived with \emph{GNP}~\cite{ng_gnp_2001}. 
%%AD what is GNP??? How did it "land" here???
%%
The latter has been also attributed by~\cite{WSS2005} to 
the iterative neighbor selection process which that is 
reportedly prone to premature termination at local minima.
%%
\cite{cox_vivaldi_2004} argues that elements of the protocol's
spring relaxation technique require a centralized implementation 
affecting \emph{Mithos} scalability.
%%AD rephrased what is below as above...
% Another point that has negative effect to the
% scalability of the algorithm is that parts of its spring relaxation technique
% require a centralized implementation~\cite{cox_vivaldi_2004}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In regard to the $3$ criteria, \emph{Mithos} stands as follows:
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% It has very good results in reducing communication latency among peers but its
% efficiency is being constrained by the fact that the proximity is calculated
% at bootstrap, assigning virtual coordinates that are used throughout of a
% nodes life cycle and thus the overlay is not adapting to a high-churn
% environment.
medium &
% Incremental probing is applied in quadrants and in two-hop distance at each
% step that does not generate a lot o control overhead.
medium &
% It is constrained by the fact that the protocol does not respond to dynamic
% peer arrivals and departures
low
\end{tabular}
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{LAPTOP}
\emph{LAPTOP} \cite{WLH2007} organizes the overlay 
%%AD what is the nature of the "structure" overlay here???
into a tree-based hierarchy so that 
hops required during message routing be reduced and 
maintenance overhead be minimized.
A caching scheme is also used so as
to further lower routing table update costs. 
It is theoretically shown that 
\emph{LAPTOP} routing path length is bounded by $O(log_d(N))$ and node
joining and leaving in the overlay network is bounded by
$O(d*log_d(N))$ hops in a balanced overlay tree with $N$ representing the
number of nodes and $d$ the maximum degree of each node. 
\emph{LAPTOP} 
%% implements 
adopts the geographical layout approach  
and constructs its layout in a self-organizing and 
efficient fashion. 
The physical distances are estimated
with round trip times to a few existing nodes in the overlay network.
%%
Each node is assigned a dot-formatted address (e.g., 1.3.4). 
Each octet ranges from
$1$ to $d$.
%  where $d$ is the maximum degree of the nodes. 
%%AD this definition was provided just above.. 
The assignment process is done by appending a unique octet 
to the address of the parent of each node, while
the root node is assigned address $1$.

%The protocol is based on four definitions.
%\begin{enumerate}
% \item The amplitude of all possible measured RTTs is divided into intervals.
%  Each node measures its distance to its parent and is assigned a label $L_i$
% where $i$ denotes the configurable RTT interval in which the measured distance
% falls into. A special kind of node, the root, is initially assigned the $L_1$
% label and maintains (as all $L_1$ nodes do) a list of other $L_1$ nodes in the
% overlay.
% \item Any node can have children with level lower than theirs, except an
%  $L_{max}$ node which can only have $L_{max}$ level children and only in the
% case when its parent has reached its maximum degree.
% \item Each node is assigned a dot-formated address (e.g 1.3.4). Each octet
% ranges from
% $1$ to $d$, where $d$ is the maximum degree of the nodes. The assignment
% process
% is done by appending a unique octet to the address of each nodes parent, while
% root node is assigned address $1$.
% \item For any descendant node $Y$ of a node $X$, the measured distance among
%  each other, must always be less than the lower bound of the RTT interval
% denoted by $X$'s label.
%\end{enumerate}
%

\emph{LAPTOP}'s routing scheme is similar to the 
longest-prefix \emph{IP} matching scheme. 
At each forwarding hop, a message travels up the tree 
until the first common ancestor of both source and destination nodes 
is reached and then, the message starts descending towards its target. 
During tree traversals, special entries in the routing tables, 
called \emph{routing cache}, 
%%AD clarify - routing caches are the special entries OR the routing tables???
are maintained to increase routing efficiency and achieve finer--load balance. 
Caching enables a node to forward a message to a better 
longest-prefix match than that of its direct ancestor yielding
a larger, quicker and more cost--effective step through the overlay towards
the destination. 
To improve scalability, the number of child nodes and the
size of the routing cache are limited. 
To contain maintenance costs, \emph{LAPTOP} employs 
a simple \emph{heartbeat}-based regime in which 
a parent is responsible for the monitor of its own children.
%%AD rephrased what is below as above.. 
% In terms of overlay maintenance, \emph{LAPTOP}
% incorporates a simple \emph{heartbeat}-based technique 
% where each parent node is
% responsible for monitoring its children.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%The new comer $N$ locates the root node and the later responds with a list of
%  $L_1$ nodes. $N$ then probes each of the $L_1$ nodes in search for the
% closest one. If the measured RTT to the closest $L_1$ falls into the first
% interval then the new comer becomes a $L_1$ node as well. Otherwise node $N$
% sets the closest $L_1$ node as its potential parent node. This potential
% parent becomes the actual parent if it does not have any other children. If it
% has, $N$ gets a list of these $L_i$ nodes and by measuring the RTT to each of
% them tries to spot a new potential parent in order to repeat the above
% process.
%
%
% At join process the new coming node is assigned its level label as well as its
% address by its parent node. Additionally, it initializes its routing table
%(with normal and caching entries) as it traverses the overlay in search for
%its parent node.  During a graceful departure, the referred node checks for
%children in the overlay. If it does not have any, it simply notifies its
%parent and leaves. If it has, it selects the child node with the lowest
%round-trip time to it in order to take its place so that the locality
%property is preserved. On the other hand, in the case of an arbitrary
%failure, after the children of the failed node detect their parent's absence
%(through the aforementioned heartbeat mechanism), they start emitting special
%messages to their grandparent node (the address of which is stored during
%join process}. In case of no response from the grandparent node, the children
%invoke the joining process to detect their new parent node.The parent of the
%failed node, aggregates the notifications from the above children nodes for a
%period of time, and then chooses the one with the lowest level label as the
%takeover node. Potential ties are broken by favoring the lower RTT. The
%parent of the failed node, finally informs accordingly all the children about
%the change in the hierarchy.
%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% TODO: HERE STRUCTURED LANDMARK BINNING APPROACH LIES
%
%Assuming a structured approach based on CAN\cite{ratnasamy_can_2001} and $m$
% landmark nodes. The coordinate space is then partitioned into $m!$ equally
%sized portions, each corresponding to a single ordering of the landmarks. To do
%this, the first dimension is divided into $m$ areas each of which is further
%divided (second dimension) into $m - 1$ sections and so on. Having set this $m$
%dimensional space, at joining time, a node measures the delay to the set of
%landmarks in order to determine its associated bin and thus position itself in
%that portion of the coordinate space associated with its landmark ordering.
%Even though this scheme can
%
\emph{LAPTOP}'s behavior for the $3$ criteria stands as follows:
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% It minimizes routing length, but may suffer load imbalance since nodes higher
% in the tree hierarchy are more likely to route most of the messages in the
% overlay.
medium &
% Heartbeat approach incurs extra control overhead to the network. Fortunately
% involves only the parent and the children of the departing/failing node.
% nodes.
low &
% Seems to scale nicely from 10K- to 1M-node testbeds.
high
\end{tabular}
}
\end{center}


%###############################################################################
%###############################################################################
%###############################################################################
%       PROXIMITY ROUTING
%###############################################################################
%###############################################################################
%###############################################################################


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Proximity in Kademlia}
% Before discussing {\em Proximity in Kademlia}, it would be helpful to briefly
% summarize the highlights about the {\em Kademlia} protocol. {\em Kademlia}
% \cite{maymounkov_kademlia_2002} is a distributed hash table (DHT) based
% protocol for \p\ networks, which uses an iteration based lookup algorithm. The
% protocol uses the standard $160$ bit ID system for nodes and locates the nodes
% in a prefix binary tree, where IDs are used as prefixes. The iterative lookup
% operations are done over this prefix binary tree, which converges to
%logarithmic
% lookup times. The ID's are assigned randomly, therefore in Kademlia, there is
%no
% proximity control, which results in inefficient use of the underlying network
% during lookup and retrieve operations.


In order to optimize the underlying network use,
\cite{KLKP2008} introduces proximity
controls over the \emph{vanilla Kademlia} 
protocol's random \emph{ID} assignment.
% The work in this paper
% can also be considered as a more generic study of incorporating proximity into
% iterative lookup algorithms.
In its quest to improve routing performance, the overlay uses 
a cost ``yardstick'' (i.e., metric) provided by the underlying network.
% The overlay tier improves its routing performance using a cost--metric that is
% provided by the underlying tier. 
Such cost information can be acquired by
\begin{inparaenum}[\itshape i\upshape)]
  \item measuring previous lookups,
  \item exchanging or jointly-computing measurements with 
	others, or 
  \item using a local database to look--up information.
\end{inparaenum}

\cite{KLKP2008} exploits $2$ routing techniques: 
\emph{proximity routing selection (PRS)} and 
\emph{proximity neighbor selection (PNS)}.
%%
In \emph{PRS}, the goal is to choose the best next hop while routing a message.
\emph{Plain old Kademlia} (\emph{POK}) always selects the closest--node 
with respect to the \emph{XOR} metric.
With \emph{PRS} in place however, \emph{Kademlia} may also choose 
the node that exhibits the smallest underlay metric cost; in this way, 
it balances a trade-off between the logical overlay and 
actual underlying distances.
%%AD rephrased as above.. the "underlay" I am not sure what it is...
%  but with proximity routing, Kademlia should also choose the node
% that exhibits the smallest underlay metric cost, balancing a trade-off between
% the overlay and underlay progress distances.
%%
In \emph{PNS}, on the other hand, the goal is to keep peers 
with the least contact cost in the routing table. 
%%AD WHAT is this "least contact cost"?? Sounds funny! CHECK
As \emph{Kademlia} continually learns about new
peers via incoming requests and an iterative lookup process, 
%%AD what is this iterative lookup process???
no specialized algorithm is required for searching for 
more cost-effective peers 
and the system simply goes for the best peers ``seen'' thus far.

\emph{Kademlia} proximity injection improves 
locality of connections among peers.
To enhance traffic locality, the use of 
{\sl MaxMind GeoIP} database~\footnote{\url{http://www.maxmind.com}} 
is suggested to form clusters of nearby peers.
To this end, Vivaldi coordinates~\cite{cox_vivaldi_2004} could be 
also used as an alternative for morphing locality. 
\cite{KLKP2008} however suggests that the clustering approach 
when combined with \emph{PRS}/\emph{PNS} helps contain 
$40\%$ of messages within an \emph{ISP} and allows only a $6\%$ 
to go through the backbone.
The behavior of the proposal with respect to the stated criteria is deemed as follows:
%%
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Uses static information to cluster nodes which is not the most efficient
% approach in dynamic systems
% PNS reduces lookup latencies by 66\% compared to POK
medium &
% 
medium &
% MaxMind is commercial and cannot be used by FOSS P2P systems. Trying to
% expose information from P2P client can result in security issues.
medium
\end{tabular}
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{CHOord considering Proximity on IPv6 (CHOP6)}
\emph{CHOP6} \cite{MT2007} roughly estimates the proximity among
nodes by exploiting the {\sl IPv6} address format and if available, 
\emph{RTT} information.
The proximity estimation is achieved by introducing a $64$-bit 
\emph{ID} scheme in which
the least significant bits are the {\sl IPv6} global routing prefix.
Thus, a longest--prefix match scheme is established.
% enabling a longest prefix match scheme. 
%%AD check is the word "longest" is correct..
The protocol is designed based on the
observation that it is feasible to estimate a node's geographical location by
examining the upper $32$-bits of its {\sl IPv6} address. 
Moreover, similar to \emph{Chord}~\cite{stoica_chord_2001}, 
\emph{CHOP6} uses a finger table, whose entries hold
more than one candidate node.
%
%\paragraph{}
% There are three cases in which a node chooses the next hop according to
% information it possesses.
%\begin{itemize}
% \item When no information about RTT is available candidate next hops, the
%  sender just selects a node in the finger table entry which shares the longest
% prefix with the destination.
% \item There is another possibility that after some communication with other
%  nodes, the source node should know of the RTTs to some of the nodes in finger
% table entry. In this case, the source node chooses the one with the smallest
% RTT with probability $p$. If there is a node with no measured RTT then the
% sender can select such a node with probability $1 - p$
% \item In this last case the source node has already communicated with all
%  candidate node in the finger table entry. Thus, the node selects the node
% whose RTT is the smallest with probability $p$, the one with the second
% smallest with probability $q$ and so on, where $0 \leq \ldots < r < q < p < 1$
% and $p+q+r+\ldots \leq 1$
%\end{itemize}
%
With respect to the $3$ qualitative criteria, \emph{CHOP6} stands as follows:
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Simple approach that exploits proximity but it is coarse grained and thus not
% efficient.
low &
% Its static nature imposes low overhead to the network
low &
% IPv6 is still not widely applied and supported.
medium
\end{tabular}
}
\end{center}
%%AD how does CHOP6 helps with the mismatch problem?? 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{T2MC}
\emph{T2MC} \cite{SLCGZ2008} uses traceroute logs to detect 
the boundaries of an autonomous system (\emph{AS}) and
cluster nearby peers; the objective here is to 
diminish the redundant multiple messages that may 
unnecessarily cross \emph{AS}-boundaries.
\emph{T2MC} uses a customized $k$-mean classification
algorithm with $k = 2$ to perform the classification 
and exploits the stable structure of the Internet routers 
to help guide the clustering in question. 
Even though {\sl traceroute}
provides detailed information about the network structure, 
it extensive use may create overhead on the overall network structure. 
In this respect, it is often the case that administrators 
disable {\sl traceroute} support on their routers.
The latter may affect \emph{T2MC}'s performance.
%%
Although overall experimental results have been encouraging, 
\emph{T2MC} is considered coarse-grained
as it classifies peers into only ``remote'' and ``close''
groups \cite{QLZG2009}.
%%AD a better connection with the mismatch problem has to be made... 
%%		.. in the form of 1-2 lines (or short statements). 
%%
%
%T2MC \cite{SLCGZ2008} uses trace-route logs to detect different autonomous
%systems and cluster close by peers, thus reducing redundant traffic that crosses
%autonomous system boundaries. T2MC uses a customized k-mean classification
%algorithm with $k=2$ to perform the classification, and exploits the stable
%structure of the Internet routers to guide clustering. The peer chooses the
%minimum and maximum Latency results from the trace-route to initialize the
%centroids of two sets. Then the peer calculates, for all hops along its
%trace-routed path, the peer calculates the absolute distance to these centroids
%of both sets and assigns the routers to that centroid with which it has the
%smaller absolute distance. After that, the mean and variance values are
%calculated and if the variance is larger than a predefined threshold then the
%algorithm sets the two latency mean values as new centroids for the two sets and
%loops again. Ultimately peer will end up with two sets having the minimum
%intra-set variance. The peer, then, chooses the router from the second set with
%the minimum hops attribute and sets it as a threshold. The selected router and
%all others whose hops attribute is larger than the threshold are classified as
%\emph{remote} router cluster. The remaining are classified as \emph{near}. From
%the near class, the peer chooses the one with maximum hops attribute as its edge
%router, and registers it along with all near clusters into the DHT of the
%\p\ overlay. As new peers join the network, those that share the same edge
%router or any of the members of the near router clusters, would form a close
%peer cluster. As Edge routers can provide more valuable information than other
%members of the near set, T2MC was designed to prioritize interaction of peers
%and edge gateways.
%
%
% TODO: SOME DISCUSSION
%
%The use of Trace-route as a tool for implementing the distance measuring
%infrastructure raise concerns about its efficiency and scalability. Being,
%primarily, a network diagnostic utility,
% Even though trace-route provides detailed information about the network
% structure, its excessive use creates additional overhead that stresses further
% the overall network infrastructure. This forces network administrators to
% disable its support from the routers they manage, thus jeopardizing the
% effectiveness of the T2MC algorithm.
%
\emph{T2MC} fares as follows:
%%
\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The efficiency of choosing close by peers is very good and reported almost
% 65\% better than that of GNP (and thus generally of static landmarking as a
% whole)
high &
% trace-route is a very heavy tool and thus incurs excessive burden to the
% network resources.
high &
% Trace-route is categorized as too heavy-weighted and intrusive for use in a
% larger scale system \cite{RKHS2002}. Additionally, disabling
% ICMP is a common administrative policy for edge sites to enforce security,
% while dumping BGP routing tables\cite{krishnamurthy_bgpclust_2000} is not
% directly available to the application layer.
low
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{PChord}
\emph{PChord} \cite{HLYW2005} is based on the \emph{Chord DHT} and adds
proximity into its routing mechanism. 
The main modification over its predecessor is the inclusion 
of a \emph{proximity list} into its routing table;
in this way, the next hop can be decided based on both the best progress
towards the key and the physical proximity of the candidate nodes.
%%AD I am not sure about the "best progress" term - what does it really mean???
%%
At join time, this list in empty. 
As the \emph{PChord} node starts to interact with
others, it applies a heuristic mechanism to fill the list. 
Entries are dynamically added or removed as the network state changes. 
The overlay maintenance cost is similar to that of \emph{Chord}. 
%%
Apart from the costs incurred when a  node joins in or departs and 
by heart-beat messages used for connection verification, \emph{PChord} adds
heart-beat among nodes it the proximity list. 
Fortunately the latter is kept to a minimum provided that 
the list entails nodes presenting very low \emph{RTT}s.
%%AD removed "lowest" to use lowest u must have a set or something...

As there is always progress towards the target in the \emph{ID}-space,
\emph{PChord} yields a reduced number of hopes that \emph{Chord}.
%%AD rephrased as above - the 2 last lines of the text below are 
%%		are difficult to decipher... 
% Due to the fact that, with each step, there is always 
% progress towards the target node in the ID space, 
% \emph{PChord} will result in a reduced hop number than
% Chord, since each hop in \emph{PChord} is larger or 
% at least equal in the key space.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
Passing through proximity links, in the underlying network, 
means reduced routing cost. 
Moreover, if the number of entries in the proximity list is the same
as the number of network partitions, 
\emph{PChord} prevents hops from jumping in and
out of network partitions the current node belongs to.
%%
On one hand, 
\emph{PChord}’s advantageous  points are that 
its routing attains fewer overlay hops, 
it crosses network partition(s) only once by following proximity links
and it maintains the light-weight maintenance cost of \emph{Chord}.
On the other, \emph{PChord} exhibits slow convergence speed 
and inefficiency in high-churn environments~\cite{DK2006}.
%%AD rephrased what is below as above... 
% \emph{PChord}’s advantages include the fact 
% that the main routing optimizations are of
% less overlay hops, following proximity links and crossing the same network
% partition only once along a routing path while in the same time keeping Chord's
% light-weight maintenance cost. 
% On the other hand, it exhibits slow convergence
	% speed and inefficiency in a high churn environment \cite{DK2006}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\emph{PChord} qualitatively behaves as follows:
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Small decrease in needed overlay hops per object publishing but rigid in
% high churn environments.
medium &
% The are heartbeat mechanism for both finger table and proximity list adds a
% burden to the network by default. But the overall overhead is decreased as
% the proximity list becomes longer.
medium &
% Improvement of routing is achieved with more object pointers helping to
% shorten the routing path of object querying. When the distance of query source
% to target is far away both Chord and PChord achieve the average hop number to
% not increase.
medium
\end{tabular}
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{AChord}
\emph{AChord} \cite{DK2006} uses the {\sl IPv6} any-cast mechanism to
relieve the protocol from complex joining procedures,
harness network proximity and achieve high routing efficiency. 
Any-cast delivers a message coming from the outside of 
an any-cast group to the physically closest node in
that group~\cite{M2002}. 
\emph{AChord} organizes all nodes participating in the
overlay network into an any-cast group. 
Any joining node comes outside of that group and, thus, is
automatically forwarded to the physically nearest node for bootstrapping;
this avoids the need to explicitly maintain such nodes, %%AD such nodes???
and the effort of locating the physically nearest. 
%%
The \emph{ID} of an incoming 
% the new-coming %%AD changed...
node is computed based on the \emph{ID} of the bootstrap node 
and the bootstrap's predecessor in a way that the constructed 
\emph{ID} is positioned between the aforementioned two. 
After joining, a \emph{finger} table is created ala \emph{Chord}. 
Moreover, an \emph{adjacency table} maintains 
information about the closest--known peers. 
The routing decision is made by using both adjacency and finger tables.
%%AD how are these 2 combined???
\emph{AChord} behavior has as follows:
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% good routing efficiency but no adaptation to high churn environments.
medium &
% Relieves the system from joining overhead and topology aware ID construction
% but doubles the information needed to be stored and maintained by the
% introduction of adjacency table
medium &
% assumes the operation of ideal underlying any-cast mechanism (meaning that
% outside messages are always routed to the nearest node which in the current
% Internet, this is not always feasible. Moreover, is designed on the basis of
% IPv6 protocol which is not widely operational yet.
medium
\end{tabular}
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Chord6}
\emph{Chord6}~\cite{XZHL2005} is a \emph{Chord}-variant that
exploits {\sl IPv6}'s  hierarchical features in order to create 
a substrate that reduces inter-domain traffic among service providers. 
The key difference between
\emph{Chord6} and \emph{Chord} lies on the identifier definition. 
Therefore, the approach can be easily portable to other 
\emph{DHT}s including \emph{CAN}, \emph{Pastry} and \emph{Tapestry}. 
\emph{Chord6}'s identifier contains two parts: 
the higher bits are obtained by hashing the
node's {\sl IPv6} address prefix of specific length, 
while the remaining lower bits are the hash-value 
of the rest of the {\sl IPv6} address. 
As a result of this assignment, nodes in a domain are mapped 
onto a continuous key space on the overlay network;
the latter avoids unnecessary message--forwarding across different
service providers and helps minimize overall routing cost.

\emph{Chord6} does reduce the average system path length to be
logarithmically proportional to the number of available domains 
instead of the number of participating peers. 
However, due to the large number of Internet
domains and the possibility of occasionally having only 
small number of peers within each domain,
\cite{DK2006} challenges the approach's scalability and efficiency.
%%
Overall, the approach fares as follows:
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Can reduce inter-domain average path length but even though nodes in the same
% domain would have close identifiers, nodes in two close domains may have very
% different ones reducing the overall efficiency of the approach in general when
% considering inter-domain average path length. No active adaptation mechanism
% for high churn environments.
low &
% The construction of the identifier space is done at node join and in an
% independent fashion involving the application of two hash functions meaning
% resulting in low overhead stress to the network and its nodes.
low &
% Is designed on the basis of IPv6 protocol which is not widely operational yet.
low
\end{tabular}
}
\end{center}

%###############################################################################
%###############################################################################
%###############################################################################
%       PROXIMITY NEIGHBOR SELECTION
%###############################################################################
%###############################################################################
%###############################################################################

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{DHT-PNS}
A proximity neighbor selection scheme  functioning atop 
the \emph{Chord DHT} is introduced in~\cite{DLTZZ2006}.
Its key objective here has been to group physically-close nodes as 
neighbors in the \emph{DHT} table while exploiting proximity information.
To detect proximity, virtual network coordinates for 
peers are used with the help of the Vivaldi protocol~\cite{cox_vivaldi_2004}. 
The virtual coordinates are then used to help map nodes to 
the identifier--space of the \emph{DHT}.
%%
The space in question is partitioned using a 
\emph{concentric circle clustering scheme} where successive cycles of
radiuses $\rho$, $2\rho$, $3\rho$ and so on, are constructed. 
The formed annuluses are then divided into 
$2\chi-1$ \emph{sectors}, where $\chi$ denotes the
sequence number of the annulus starting from $\chi = 1$ 
for the center cycle. 
In this way, 
\cite{DLTZZ2006} prove that each sector
occupies the same area as does the center cycle. 
Assuming uniform node distribution, this characteristic,
favors a more load--balanced clustering operation. 
Every sector in this $2d$ space is mapped to 
a unique \emph{region} in the \emph{DHT} space forming a
multi-layer node identifier space.  
Consequently, nodes belonging to the same
sector, are mapped to the same region as well, preserving their proximity
relationship.
%% unveiled by the use of the Vivaldi protocol. 
%%AD I am not sure u need the above line at the end of the previous sentence.
Individual elements
are uniquely mapped to the identifier--space, 
allowing logarithmic lookup operations with high 
probability on \emph{Chord}. 
%%

%%AD what is the section u say here??? -- also the first sentence 
%%	here has to do a better connection with what was discussed before!
The system described in the previous section 
allows any node to obtain its \emph{DHT} key and its region key, in a fully
distributed manner, just by applying a consistent hash function. 
%%AD where these RPCs come from? kind of disconnected???
Using an {\sl RPC} call in \emph{Chord}, 
the node can obtain the region's master node, 
called \emph{Cluster Node (CN)} which is responsible for clustering 
the nodes belonging in the same sector or region with that of the node at hand. 
An additional {\sl RPC} call, registers it to its corresponding region 
and publishes its information, through the special peer \emph{CN}. 
The node can, additionally, ask an \emph{CN} for other
nodes that have previously joined the region to add them into its
neighbor set for future routing table optimization. Q
%%AD the one below is not a parse-able sentence!!! What does it say???
%%%		restrict the length of your sentences to say at most 2.5 lines!
Even in the case when no
neighbor is detected in the current region, the search is expanded to adjacent
regions and towards an upper layer identifier space until one is found or the
first layer reached. Simulations suggest that the scheme has good convergence
property of the delay distribution and good optimizing performance.
%%AD up to here the text in this second paragraph for Chord DHT remains 
%%%%%		... rather cryptic - does need work and better connection 
%%%%%		with the 1st paragraph...
%%
Unfortunately, even though scaling appeared promising, only limited 
simulations carried out with configuration involving up to 2,048 nodes 
were carried out.
% where made on rather small test beds (of at most 2048 nodes), so no safe
% conclusions can be deduced. 
Moreover the approach assumes uniform node distribution which
is not always the case, especially in a synthetic coordinate system.
%%
\emph{Chord DHT} fares as follows in reference to the $3$ criteria:
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
%
medium &
%
medium &
%
medium
\end{tabular}
}
\end{center}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Quasi-Chord}
\cite{SZ2008} proposes \emph{Quasi-Chord}, a \emph{Chord}-based network that
constructs its overlay network while attempting to match the underlying 
network topology.
The overlay creation follows $3$ stages:
first, each host acquires its coordinates in
a geometric space using the \emph{Global Network Position (GNP)} protocol
\cite{ng_gnp_2001} and a set of landmarks.
Second, using the \emph{Cantor} space--filling curve, 
the $2$-dimensional is converted to $1$-dimensional space. 
The latter is employed in the third and final stage to build 
the \emph{Quasi-Chord} circle according to the host's \emph{Cantor} value. 
Physical proximity is thus denoted by \emph{Cantor} value proximity. 
The \emph{Chord} cycle is constructed by sorting nodes in 
ascending order. In \emph{Quasi-Chord},
each node stores $2$ finger tables; one clockwise and one counter-clockwise.
%%AD what is the purpose of this? efficiency to go back and forth???
%%
%
%In the following paragraphs, these steps are further discussed.
%
%\paragraph{GNP coordinates}
%First of all the host must be positioned in the geometric space. The algorithm
%  models the \p\ network with a well defined distance function in such a way,
% it can predict, with high accuracy, the distance between any two points in the
% space by just evaluating the output of the distance function on the
% coordinates of these points. This is accomplished with the \emph{global
% network position (GNP)} protocol which\begin{inparaenum}[\itshape i\upshape)]
%  \item creates a reference set of $N$ landmark nodes so as to minimize the
%  error of ICMP measured distances and coordinate computed ones between them,
% and then
%  \item each host is able to measure its round-trip times to the $N$ Landmarks
% in order to compute its own coordinates.
%\end{inparaenum}
%
%\paragraph{Cantor SPF}
%After the $2$-d coordinates are set, in the next stage of the algorithm, each
%  participating peer is assigned a Cantor value, according to the application
% of a \emph{space filling curve} on the coordinate space. (TODO: add figure).
% This results in the conversion of the $2$-dimensional space to a
% $1$-dimensional Cantor space that can more easily be more mapped to the Chord
% hierarchy.
%
%\paragraph{Quasi-Chord construction}
%As can intuitively be inferred by observing the Cantor chart, close-by nodes in
%  the physical layer, are more likely to have similar Cantor values. This
% attribute is exploited in order to construct a topology-aware identifier space
% for the Chord DHT. The cycle is constructed by sorting nodes in ascending
% order. Each host maintains 2 finger tables, one for clockwise and one for
% counter-clockwise stepping. This helps with the connectivity of the network
% because its not allowed to connect the first node with the last one since this
% will incur heavy traffic to the later\footnote{After all their Cantor values
% denote that they are actually the furthest of each other.}.
%
%
%
% TODO: SOME DISCUSSION
%       NEEDS DOUBLE-CHECK
%
%The disadvantage of the algorithm is that the coordinate assignment in the
%  first stage is backed by a not fully distributed landmark-based algorithm.
% Moreover the Quasi-Chord model build-up is making an indirect assumption of a
% maximum number of allowable hosts since it is constructed. Last but not least
% the doubling of the required routing information which needs to be created and
% maintained is an additional negative point to the efficiency and the
% scalability of the algorithm.
%
%%
\emph{Quasi-Chord} qualitative behavior has as follows:
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The algorithm shows to reduce end-to-end delay as well as not produce
% duplicates of messages.
medium &
% The overhead is more compared to vanilla chord since mapping of 2-dimensional
% space to 1-dimensional with Cantor SPF adds some extra burden in time
% complexity. Also the addition of the counter-clockwise finger table doubles
% the data, per se, needed to be stored and maintained.
high &
% The GNP system is a static landmark approach making things not fully
% distributed and thus constrain the model's scalability.
medium
\end{tabular}
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{IP-based Clustering (IPBC)}
Proximity neighbor selection algorithms often use probing 
% and other techniques
%%AD say what are these "other" than simply say so... 
to detect proximity. 
However, such methods suffer by imprecisions often due to network overload.
{\sl IP}-based clustering~\cite{KM2007} 
% is a proximity neighbor selection algorithm which  %%AD u do not need this!
uses {\sl IP} address prefixes ($16$ bit for {\sl IPv4}) 
to detect proximity. 
%%AD where this IPBC came from?
\emph{IPBC} clustering generates a key and its prefix %%AD this ... "and" is not 						      %%    clear!!!
and stores the prefix in the \emph{DHT} itself;
in this way, newly joining nodes with the same {\sl IP} prefix 
can query the \emph{DHT} and readily
identify all neighbors with the same prefix.  
Nodes periodically update their entries in the \emph{DHT} 
by removing those who leave or have timed-out.
%%

The overhead of the algorithm is very low as proximity detection requires only
a comparison of prefixes. On the other hand, the efficiency of the proximity
is caught into a vicious cycle with the storage space needed for \emph{DHT} 
object publishing (how many bits will be used for either). 
%%AD did not get the parenthesis above - what is "either"???
%%	I am not sure what the sentence below says and 
%%	how is connect to the above
Moreover, its static nature (no online measurements used) 
makes it difficult to handle~\cite{EWF2011}.
%%
% Moreover, observing the
% \emph{IANA IPv4 Address Space Registry} we can infer that, since blocks of
% consecutive octet prefixes are assigned to the same Regional Internet
% Registries (RIRs), nodes inside will be physically close to each other.
%
%
% In order to be published in the overlay, each node is first assigned a
% unique identifier and subsequently generates a key by hashing a fixed-length
% prefix of its IP. Authors argue on the prefix length to be used, as there is a
% thin balance between reducing the probability of finding closer nodes by
% adopting a long prefix and overload nodes that are responsible for information
% published by many peers when choosing to hash a short one. Their verdict is
% for
% the use of a 16-bit wide prefix for real world systems deployed in an Internet
% scale. In either case, ID and IP is then stored in the DHT using this
% generated key. This way, any node, at any time (either at join time or during
% peer lifetime for topology adaptation) can acquire information about close-by
% nodes just by querying the DHT for a specific key. Moreover, the algorithm
% takes care of the freshness of the proximity information in two ways. First,
% the advertising nodes themselves periodically update their advertisements or
% when they voluntarily leave the overlay, they explicitly remove their data. On
% the other hand, in case of a failure each publication is assigned an
% expiration time, and thus ultimately removed by the DHT maintenance
%mechanisms.
%
The suggested approach fares as follows:
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The efficiency of proximity detection through the prefix matching technique
% is caught in a vicious cycle with the storage space needed for DHT object
% publishing (how many bits will be used for either).
low &
% The overhead for detecting proximity is only comparison of prefixes
low &
%
medium
\end{tabular}
}
\end{center}

%%AD how the 2-level thing helps the mismatch  problem?? 
%%	ALSO, why the symbolism of the layers is required?? Ld_Cord Ld_Cone
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Cone}
\emph{Cone} \cite{HY2007} extends \emph{Chord} using a proximity neighbor
selection topology optimization algorithm. The proximity information is
generated using landmarks and round-trip-time-based distances to 
those landmarks. %%AD added those.. 
%%AD how is this better/worse than the one just above based on IP clustering???
\emph{Cone} uses a two-layered identifier space. The first layer is 
identical to that of \emph{Chord} and is denoted as $Id_{Chord}$.
% \emph{Chord}-layer identifier and denoted as $Id_{Chord}$, 
% is the same as in Chord. 
The second layer identifier known as \emph{Cone}-layer and denoted as 
$Id_{Cone}$ is generated using two IDs. 
The first, known as \emph{group identifier (gid)} denotes a
relevant group to which the node belongs to while the second, 
namely \emph{local identifier (lid)} indicates the % local 
identifier within the group. 
The group is used here as means to divide nodes according to  a
% concept is a way of dividing nodes according to a
common $Id_{Chord}$ prefix.  
The \emph{Cone} overlay retains the \emph{Chord}'s circular topology. 
The difference lies in the fact that, now, $2$ rings are created. 
A big one in which nodes with the same \emph{gid} are arranged 
% at each position.  %%AD I do not get thus at EACH position!!!
in the same position.
Each of these positions constitute a smaller ring for the particular
group's \emph{lid}s. 
%%%
Routing is achieved in both clockwise and
counter-clockwise directions in the big-ring, for which two routing tables are
maintained: \emph{front} and \emph{back} finger tables. 
Entries in these tables, display physical network proximity 
with the current node. 
Moreover, a third table called \emph{group} maintains 
information about other on-line peers
within the current node's group in a way that 
entries are now close in the \emph{id} space. %%AD check rephrasing...
%
%Routing in Cone, comprises of the inter-group algorithm and the intra-group
%  algorithm. First the group of nodes to which the desired key lies is
% detected, exploiting physical proximity information (front and back finger
% tables). Second during the next and last hop, the message is forwarded to the
% exact node that contains the desired key.
%
\emph{Cone} fares as follows: 
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The result of experiments show that the Cone, compared with Chord, has obvious
% improved on the delay of route and the hops of overlay networks…
medium &
% The approach incorporates a static landmark + RTT to these landmarks in order
% to exploit proximity information thus incurring low overall additional
% operational overhead but imposing extra stress to the landmarks themselves.
% Additional information must be maintained, three finger tables (front, back and
% group)
medium &
% landmark based approaches are not full distributed thus not smoothly scalable.
medium
\end{tabular}
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{DynaMO}
\emph{DynaMO}~\cite{WZS2004} attempts to create an overlay that 
does not only consider physical proximity amongst peers but also
takes into account mobility attributes of nodes.
To adapt to mobile ad-hoc networks, \emph{DynaMO} strives
to maintain an evenly--distributed overlay \emph{ID}-space 
so that hot-spots are avoided. 
%%
Although based on the \emph{Pastry} overlay and 
it well understood built-in locality heuristics ~\cite{CDCR2002a},
\emph{DynaMO}'s own mechanisms are \emph{DHT}-independent and 
so, they can be applied to other \emph{DHT}s.
%%AD rephrased/shortened above - check
%%
\emph{DynaMO}'s approach may be viewed as bottom-up. 
An incoming node computes physical information about its neighborhood
and uses the outcome to unilaterally assign itself an \emph{ID}.
The proposal is based the fact that with every new overlay  routing-hop
the physical distance between nodes is likely to increase
resulting in a dominating 
last routing step~\cite{antony_pastry_2001,CDCR2002a}.
To identify this step, two techniques are used: 
\emph{Random LandMarking (RLM)} and 
\emph{Closest Neighbor Prefix Assignment (CNPA)}.
%%AD rephrased as above - check!
% A new-coming node is required
% to compute physical information about its neighborhood 
% and use it to unilaterally assign itself the an ID. 
% \emph{DynaMO} is building on the
% observation that with every new overlay routing hop the physical distance
% between nodes is likely to increase, resulting in a dominating last routing
% step \cite{antony_pastry_2001,CDCR2002a} and for this two methods are discussed,
% \emph{random landmarking (RLM)} and \emph{closest neighbor prefix assignment
% (CNPA)}.
%%%%%%%%%%%%%%%%%%%%%%%%%%

In \emph{RLM}, a set of peers are chosen to be responsible 
for a set of landmark keys. 
These keys have to be chosen in a way that they equally divide the overlay
space. 
%%AD how do you accomplish the above?? 
An incoming peer then computes distances from those landmarks,
sorts them, and assigns itself an \emph{ID} on this 
landmark ordering as follows:
% The new-coming peer then computes distances to those
% landmarks, sorts them and assigns itself an ID based on the landmark ordering.
the peer adopts as \emph{ID} having a prefix from its closest
landmark; the length is 
$l_{prefix}=|log_b k|$, where $b$ is the \emph{ID} base 
and $k$ the number of landmarks. 
The remaining of bits of the peer-\emph{ID} are assigned either 
randomly or computed with additional proximity optimizations.
In this way, two desirable features are attained:
% What is achieved is that
\begin{inparaenum}[\itshape i\upshape)]
  \item landmark assignment is dynamic, and
  \item the set of a node leaf may reference peers that are 
	physically close by.
	%%AD I am not sure why is that?? But it is ok...
\end{inparaenum}
The latter in particular helps reduce average routing cost(s)
for the leaf-set of a node is used to efficiently determine the 
last routing step.
% (since it contains the nodes closest in the overlay space).
%%AD I do not think you need the above.. %%AD Also rewriting..
%%
%%
\emph{CNPA} is proposed for network setups for which a lightweight
bootstrap phase is required.
It delegates to \emph{Pastry} the task to identify the physically
close--node with which an incoming peer gets bootstrapped. 
The new-comer assumes the bootstrapping nodes's \emph{ID} prefix 
and fills the remaining of its key using the techniques of \emph{RLM}.

\emph{RLM} gets evaluated as presenting good proximity in a load-balanced 
environments. Moreover, it is adaptable to high-churn settings.
Unfortunately, \emph{RLM} bootstrap overhead is substantial and can 
effect  the set of temporary landmarks.
\emph{CNPA} on the other hand, incurs less overhead but this come 
at the expense of being more coarse-grained.
%%AD  Rephrased as above.  -- In the above I am not clear 
%%	a) what are the "temporary" landmarks? b) what is coarse-grained 
%%	and why??? 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \emph{RLM} achieves good proximity evaluation in a load balanced and adaptable to
% high churn environments fashion. Unfortunately it comes with more bootstrap
% overhead that can especially effect the set of temporary landmarks. On the other
% hand, \emph{CNPA}'s less incurred overhead comes at the expense of being more
% coarse-grained.
%%%
%%
% \emph{DynaMO} tries to capitalize on the fact that in Pastry each node's table consists
% of rows equal to the number of digits in the overlay ID and columns equal to
% the ID's base. As we go down the table rows, the matching prefix between the
% current node's ID and the row's entries increases by one. Thus, the leaf set
% contains the closest nodes in the ID space. Additionally, as the prefix match
% increases by one, the result is exponentially fewer candidates that can fill the
% tables entries as the row increases. This leads to the observation
%  In this context, two approaches are considered namely
% \emph{Random Landmarking (RLM)} and \emph{Closest Neighbor Prefix Assignment
% (CNPA)}.
%
% TODO: SOME DISCUSSION
%
%Both algorithms, are protected against the formation of physical landmark
%  clusters or imbalanced ID distribution\footnote{More common during the
% initial formation of an overlay network} , by introducing the \emph{landmark
% gravitation range} as a threshold over which landmark keys are reassigned (for
% the RLM approach) or unutilized ID prefix ranges are detected and used (for
% the CPNA scheme) in order to balance the distribution of regions in the
% overlay.
%
\emph{DynoMO}'s elements fare as follows regarding our $3$ criteria:
\begin{center}
{\footnotesize
\begin{tabular}{rccc}
\multicolumn{1}{r}{} &
\multicolumn{1}{c}{\emph{Efficiency}} &
\multicolumn{1}{c}{\emph{Overhead}} &
\multicolumn{1}{c}{\emph{Scalability}}
\\
\cline{2-4}
\emph{RLM} &
%%
%% TAKEN FROM
%% Efficient service discovery mechanism for wireless sensor networks
%%
%%
% common prefix of the overlay ID with the closest landmark. The
% RLM utilizes the overlay lookup capabilities by reducing traffic
% overhead within an overlay cluster. However, it generates much
% control traffic for periodically measuring distances to all landmarks.
% Moreover, the hop stretch overhead still increases when
% performing overlay routing among overlay clusters.
medium &
%
medium &
% Dynamic landmarking approach helps the scalability of the algorithm. The
% authors claim that the temporary nature of RLM's landmark nodes does not
% prevent them to maintain a good ratio in the presence of high landmark
% digression rates.
high \\
\emph{CNPA} &
%
medium &
% % The paper suggests that this approach generates significantly lower overhead
% than the vanilla Pastry algorithm
low &
% The queries are directed through fast nodes so it is important such nodes
% be part of the network
medium \\
\end{tabular}
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{SAT-Match: Self-Adaptive Topology Matching}
% \begin{figure}[ht]
% \centering
% \subfigure[Example physical topology of nodes.] {
%   \includegraphics[scale=0.6]{img/algorithms/SAT_match}
%   \label{figure:sat_match:before}
% }\qquad\qquad
% \subfigure[(left) A jumps to B in order to match the logical topology to the
% physical. (right) State of the logical topology after the jump.] {
%   \includegraphics[scale=0.6]{img/algorithms/SAT_match2}
%   \label{figure:sat_match:after}
% }
% \caption{The SAT-Match algorithm.}
% \label{figure:sat_match}
% \end{figure}

\emph{SAT-Match}~\cite{RGJZ2004} defines an iterative process that 
adaptively changes the overlay network to ease the topology mismatch problem. 
It consists of a \emph{probing phase} in which a peer queries nearby nodes 
for distances and a \emph{jumping phase} in which the peer decides 
to change its neighborhood in order to reduce average neighbor distances. 
This process is performed unilaterally
until no additional optimization is needed but it achieves optimization within a
sufficiently large scope.
%% VM This is used in other papers. Maybe we can put somewhere in the
% definition of Topology Mismatch Problem in the intro/background.
The notion of \emph{stretch} is used as th means for quantifying 
the \emph{topology match degree} of the constructed overlay;
stretch is defined as: 
$S = \bar{L_l}/\bar{L_p}$ where $\bar{L_l}$ is the average logical link
latency and $\bar{L_p}$ is the average physical link latency.
%%AD what are the indexes: l and p -- p for peer and l for new peer???
%%AD rephrased what is below as above... 
% 
% The paper defines \emph{stretch}
% $S = \bar{L_l}/\bar{L_p}$, where $\bar{L_l}$ is the average logical link
% latency while the $\bar{L_p}$ is the average physical link latency, and uses it
% a way to quantify the \emph{topology match degree} of the constructed overlay.

The \emph{probing phase} starts when the new-comer joins the \emph{DHT} 
using the standard mechanism of the algorithm at hand. 
The peer starts probing the neighborhood with 
messages of small \emph{TTL=k}~\cite{jiang_lightflood_2008}. 
Recipients return information to the source and forward the message 
if not expired. 
After discovering its \emph{TTL}-$k$ neighborhood, 
the source measures \emph{RTT}-times, sorts them
and picks the two nodes with the smallest \emph{RTT}s.

During the \emph{jumping phase}, the source node calculates the 
stretch change of its \emph{TTL--1} neighbors %%AD each of its neighbors???
and that of the \emph{TTL-1} neighbors of the first of
the peers picked during the previous phase. 
These calculations are made as if the jump had been made. 
Should the stretch reduction is over a predefined threshold
the jump is actually performed. Otherwise,
the second selected candidate is selected and the
same computation is performed. 
%%AD is this done only 2 times?? Or is it done recursively??
If again, the threshold is not met, then no jump is ultimately carried out. 
In case of a jump, this is performed as a combination
of \emph{leave} and \emph{join} operations, in the underlying context
(i.e., \emph{CAN}).
%%AD I am not sure of the last sentence + CAN... What does it say?? context???

%%AD The following sentence says what exactly????? 
% Even though no theoretical proof is given, valid results are
% obtained and demonstrated through experimentations. 
%%%%%%%
% It is argued that since it
% is observed to achieve a $27\%$ stretch reduction when compared to a landmark
% enhanced CAN-system, it can be deduced that it performs better than landmark
% binning in terms of the matching degree.
%%AD rephrased above as below.. .
Experimentation shows that \emph{SAT-Match} 
attains a $27\%$ stretch reduction over 
a landmark-enhanced \emph{CAN}-alternative.
Based on this result, it is conjured that \emph{SAT-Match} 
may perform better than landmark binning in terms of the matching degree. 
\emph{SAT-Match} behaves as follows with respect to the stated $3$ criteria:
%%AD matching degree is unqualified here... 
%%
% Figure~\ref{figure:sat_match} demonstrates the selective jump on an
% example topology.
%
%\paragraph{}
%Moreover the algorithm takes several issues into consideration in order to
%  further improve the resulted overlay. For example when multiple nodes try
% to jump simultaneously into a region, then the logical link brakes from one
% attempt may result in inaccurate computation of the gain factor, for an other.
% This situation is identified as \emph{contention} and the nodes use an
% exponential back-off algorithm to avoid it. An other problem is the
%unnecessary
% traffic incurred by the probing phase in a region that after several jumps
% has settled to a stable state. In these cases it is more likely for jump
% attempts to be proven worthless. The algorithm doubles the probing period of
% such nodes, every time a jump is not taken.
%
%\paragraph{}
%The authors claim that this continuously adaptive mechanism achieves global
%  topology matching optimization in a sufficiently large scope. This also
% secures the fast adaptation to frequent network changes. It also considered
% lightweight and can easily be embedded into current \p\ systems, as well
% as effectively combined with other techniques, such as landmark binning.
%%
%
% TODO: SOME DISCUSSION
%
% It is reported that,
% due to the selective jumps, SAT-Match achieves $40\%$ reduction in
% link stretch, and when used with the landmark binning (see
% Sec. \ref{sec:landmark_binning}), the reduction rate increases up to $60\%$.
% For dynamic environments, with frequent node arrival and leave, SAT-Match
% scales much better than Mithos, due to its self adaptation mechanism and
% selective jumps.
%%
\begin{center}
{\footnotesize
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% SAT-Match seems to outperform landmark binning in the sense of providing a
% higher grained differentiation of proximity, adding to the fact that
% SAT-match is fully distributed. Also to further enhance the efficiency it can
% work cooperatively with landmark binning itself.
% Security is compromised with arbitrary jumps!
high &
% distance probing and iterative computations add to the approach's overhead.
% Also the fact that the selective jumps are not always performed the added
% overhead to efficiency gained is not guaranteed in any configuration and
% circumstance.
medium &
% The self-adaptation nature of the algorithm and the selective jump mechanisms
% scale much better than, for example, Mithos. The test are on a relatively
% small amount of peers, thus, no safe conclusion can be made with respect to the
% algorithm's scalling performance.
medium
\end{tabular}
}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discussion on the Algorithms for Structured Architectures}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% VM I commented out the following paragraph since it feels out of place
% (maybe better in the intro or background) or duplicated (from the intro or
% background).
%% 
% Structured \p\ network algorithms use a global distributed hash table or a
% prefix tree structure to uniquely lookup peers or their data in the overlay
% network. As all the data is kept within the overlay, each node behaves as a
% client and a server, therefore nodes join and leave according to rules
% determined by the integrity of the global data structure. The main advantage of
% the structured \p\ topology is that with the help of the global data structure,
% peers or their data can be found within the network even if there is only a
% single copy of that item present. However, each node join and leave creates
% maintenance overhead for the network due to updates required by the global data
% structure, and for networks with frequent node arrivals and departures, the
% overlay uses valuable network resources just to update the global structure.
% Nodes join the network by using a key value, which determines the location and
% the neighborhood of the new node within the network. However, assigning
% random key values to the newly inserted nodes creates non-optimal matching with
% the underlying physical network topology, therefore, increasing the overhead of
% the network even more. One solution for handling the topology mismatch problem
% is to consider the proximity of the peers when generating the key and joining
% the node to the network, so that nodes within the same network domains are
% selected as peers, or neighbors, during the overlay topology construction.

This section outlined
% gathered together  some of the most distinctive 
representative research that attempts 
to address the issue of inefficient network resource utilization 
as this is created by the network topology mismatch
in structured \p-systems.
Depending on the salient features the surveyed techniques seek to explore,
\cite{CDHR2002,CDCR2002,RSS2002} categorize the solutions based on:
%%AD the categorization is due to 3 above citations??? Us?? ;-) 
% A categorization of the methods used for achieving their goals is the
% following based on previous work from
% \cite{CDHR2002,CDCR2002,RSS2002}:
\begin{enumerate}[\itshape i\upshape)]
  \item geographic-layout,
  \item proximity routing, and 
  \item proximity neighbor selection,
\end{enumerate}

%%COM-VM Added the following to mention the hybrid/combo methodologies
Similarly to unstructured approaches, most of the approaches 
reviewed in this section entail features from multiple of the above categories. 
For example, \cite{KLKP2008}~uses both proximity routing 
and proximity neighbor selection to achieve topology adaptation 
or \emph{LAPTOP} combines geographic--layout with
replication strategies to refine its results. 
%%%
The heuristic nature of the suggested solutions opens them up 
to trade-offs which in most cases are 
highly affected by the application domain and the implementation itself.
%%AD this is like instructions for manual - I think the point is made and 
%%	so we can avoid this.. 
% Thus, the reader is advised to filter the results of each approach and try to
% think about how the points presented will work in her own particular problem.

Table~\ref{structured:table} offers a quick overview of how the surveyed 
approaches behave.  
The topics of topology adaptation, landmarking and caching/replication
are not further elaborated as they have been discussed 
in Section~\ref{section:unstructured}.
In a similar fashion to Table~\ref{unstructured:table}, we offer 
key properties of every approach 
that differentiate it from competitors and
highlight each algorithm's pros and cons.
%%AD rephrased what is below as above..
% A quick overview can be obtained in Table~\ref{structured:table}. 
% Topology adaptation, landmarking and caching/replication have been visited during the
% discussion on unstructured systems in Section~\ref{section:unstructured} so
% we will not elaborate more here. 
% As in the previous section, we provide the
% key properties of each algorithm that differentiate it from the others and
% highlight each algorithm's advantages and disadvantages.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Geographic-layout} \label{section:geographic_layout}

% In the \emph{geographic layout (GL)} category fall methods which practically
This category consists of methods that 
position physically nearby nodes together in the application space as 
Figure~\ref{figure:geographic-layout} depicts. 
This is accomplished by adjusting and maintaining the routing tables 
of all involved peers by exploiting proximity information 
that describe the overall geographic positioning of peers. 
%%AD I am not sure I follow the 1-line above... 
%%
\begin{figure}[ht]
\centering
  \includegraphics[scale=0.4]{img/pdf/geographic-layout.pdf}
\caption{Successive nodes in the overlay circle can be chosen to be from the
same or near autonomous systems (\emph{AS}).}
\label{figure:geographic-layout}
\end{figure}
%%
A number of the reviewed algorithms including 
\emph{Global Soft-State},
\emph{Mithos} and \emph{LAPTOP} resort to clustering close-by nodes in
order to reduce the network's average delay.
Landmark servers and \emph{RTT} measurements are two popular methods, which
can also be used in conjunction, to discover peers in physical proximity.
However, as already discussed, these
methods do not always yield reliable estimates for node positions over the
Internet. 
Landmark servers are not self-organizing and present maintenance
overheads. 
To serve a \p--network with millions of peers, multiple landmark
servers distributed over the world is required, a difficult proposition.
\emph{RTT}s can measure the delay between peers, but their use constitutes a
greedy method that can result in non-optimal overlay topologies;
the latter is especially true if nearby 
nodes happen to be connected through low bandwidth connections.

On one hand, managing the overlay structure based on \emph{geographic layout} 
of the nodes improves the query efficiency of the system in general. 
On the other, it tends to undermine the uniform distribution 
of peer identifiers which in turn terns to create 
hot-spots and limited node resilience to failures.
Such resilience appears to suffer as
nearby nodes are more likely to suffer collective failures~\cite{HY2007}.
%%AD changed the wording above - check...

% must
% cope with the inherent trade os associated with selecting
% identiers based on location: randomly selected identiers
% are essential for the scalability and security of the system
% and help to balance load while location-aware identiers pre-
% vent messages from taking extensive scenic routes (on the
% physical level). 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% TODO: Geographic Layout
%
%\begin{itemize}
% \item Geographic Layout\\
%The node IDs are assigned in such a way that nodes close by in the physical
%network topology, be close in the node ID space as well. Implementations that
%work relatively well with this approach have been incorporated into CAN. Nodes
%measure the RTT between themselves and a set of landmarks in order to match the
%CAN space as much as possible to the physical one. Unfortunately, the approach
%requires well known landmark servers and for that matter is  not fully
%self-organizing which can further lead to imbalanced node distribution. On
%other DHTs, such as Chord or Pastry, another problem emerges.  To gain fault
%tolerant properties, these protocols, replicate key-value pairs on neighboring
%(in the ID space) nodes. When a proximity-based node ID assignment has been
%used, the needed failure resilience is undermined by the fact that close by
%nodes are more likely to suffer collective failures.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Proximity Routing (PR)}

This category of approaches % ({\emph{PR}) 
does not require routing tables to be built using any
knowledge about network proximity. 
%%AD so if no knowledge is required what happens? How you go about 
%%%
%%AD I am not sure what the following sentence says... ;-) 
On the other hand it exploits such knowledge
to choose the best next hop when routing a message as can be seen in
Figure~\ref{figure:proximity-routing}. 
%%AD The above opening 2 sentences require re-calibration.. 
%%
\begin{figure}[ht]
\centering
  \includegraphics[scale=0.4]{img/pdf/proximity-routing.pdf}
\caption{Proximity routing takes proximity information into account during the
routing process.}
\label{figure:proximity-routing}
\end{figure}
%%
We reviewed an array of methodologies that strictly adhere to 
the tenets of this category such as \emph{Mithos} and
\emph{PChord} as well as others that function along with 
proximity neighbor selection such as \emph{DynaMO}.
%%
\emph{PR} tries to balance between choosing the node that will
further progress the routing towards the destination 
and picking the closest entry in the routing table
in terms of network proximity. 
%%AD just above in this section you have not clarified the way 
%%	routing tables get populated - u have to clarify this point 
%%	in order for the contrast here to be valid.. 
As this is very difficult to achieve,  %%AD Why so? Why is it difficult??? 
the system might end up
using a greedy approach that selects low latency paths on the overlay
which ultimately maps to (suboptimal) longer paths on the physical topology. 
%%AD in the following you make a point that should be made in the 
%%	follow up segment - no???
Thus, in general, proximity neighbor selection is considered 
as a superior method to proximity routing, however, joint uses of these two protocols are also possible. 
Moreover, they are  %%AD who is they? Confused!
less effective than geographical layout when applied to CAN(-like)
implementations.
%%AD re-work carefully this segment... 


% Moreover, the technique has been
% incorporated into a version of Chord causing an increase in the overhead of node
% joins and the size as well as maintenance cost of finger tables.

%
%\cite{dabek_cfs_2001} proposes a server selection scheme for the Chord DHT, on
%the domain of proximity routing selection. In \emph{CFS}, each node predicts
%the entire lookup latency as a function of the total number of nodes and the
%average overlay next routing peer. The problem is that it is very difficult to
%have a clear picture on the total number of nodes and the average hop latency
%from the local. This leads to rough estimations that consequently decreases
%overall performance.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Proximity Neighbor Selection (PNS)}

% \emph{Proximity Neighbor Selection (PNS)} 
Algorithms in this category populate their routing tables using
proximity knowledge as Figure~\ref{figure:proximity-neighbour-selection} 
depicts. 
%%
\begin{figure}[ht]
\centering
  \includegraphics[scale=0.4]{img/pdf/proximity-neighbor-selection.pdf}
\caption{Proximity neighbor selection dictates that proximity is taken into
account during routing table maintenance.}
\label{figure:proximity-neighbour-selection}
\end{figure}
%%
The proximity information used here is different from that of 
landmark-based systems described in Section~\ref{section:geographic_layout};
here, \emph{TTL} values between nodes (i.e., \emph{SAT-Match}) or 
\emph{IP} address prefixes (i.e., \emph{DynaMO} or \emph{Cone}) 
are predominantly used to detect proximity. 
\cite{freedman_iploc_2005} states that $97\%$ of prefixes larger
than $24$ bits belong to a single geographical location. 
However, using a smaller number of bits creates less precise results 
and a larger number of bits may increase the burden in the network
and simultaneously reduce the possible number of neighbors. 
%%
Moreover, \cite{HLYW2005} argue that such approaches can
destroy the uniform distribution in the key space and do not work in
one-dimensional key space where the mapping is restricted to 
operate at the overlay.
Therefore, a careful selection is required in terms of
performance/accuracy trade-off. 
\emph{Tapestry}, \emph{Pastry}, and \emph{CAN} successfully incorporated
proximity neighbor selection into their algorithms. 
The routing protocol in \emph{Pastry} is based on longest node 
\emph{ID} prefix matching, while \emph{CAN} uses \emph{RTT} values to
detect nearby nodes. \cite{CDCR2002a} reports that proximity neighbor
selection is an effective proximity based method.
%%AD perhaps the ending of the previous segment should be used here...


% \item Proximity Neighbor Selection\\
%Finally, the third approach, constructs the routing tables using proximity
%knowledge. Tapestry and Pastry's mechanisms of routing table
%maintenance try to minimize the distance to nodes appearing in a peer's routing
%table. Since routing is based on longest node ID prefix match, messages
%are gradually forwarded to nearby nodes at each routing step.
%\cite{castro_proximityp2p_2002} argues on how Pastry exploits proximity
%neighbor selection in order to create a scheme that is (more) location-aware
%compared to the other well-known DHTs (CAN, Chord).
%
%\end{itemize}
%
%{\sethlcolor{yellow}\hl{
%HA: Possible criteria: based on which protocol (eg Gnutella, CAN etc), peer
%selection (topology selection, cluster, cache etc), supports dynamic update,
%runtimes}}
%%\textbf{Algorithm} & \textbf{Overlay structure} & \textbf{Forwarding} &
%\textbf{Cache} & \textbf{Overlay optimization} & \textbf{Proximity information}
%& \textbf{Base protocol} & \textbf{Dynamic update} & \textbf{Runtime} \\
%
%
%{\sethlcolor{yellow}\hl{
%HA: Possible criteria2: Overlay optimization structure, base protocol (eg
%Gnutella, CAN etc), dynamic update, runtimes, scalability}}
%
%{\sethlcolor{yellow}\hl{
%HA: maybe add also the year of publication, and see if there is a pattern in
%terms of the method and the year??}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{structured-table}

\input{structured-plot}
