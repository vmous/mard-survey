\section{Structured P2P Networks}
\label{section:structured}

This section presents a description and analysis of algorithms proposed
to address the topology mismatch problem in structured P2P networks.
In structured P2P networks, the construction of the routing tables
held by participating nodes determines the efficiency of message forwarding.
Routing tables that closely match the underlying IP topology
achieve increased performance. As a result, the proposed solutions for
the topology mismatch problem for structured P2P networks 
use different levels of proximity
information to optimize the routing tables used by peers.  
The categorization of the algorithms we present here is based on the
categorization suggested by previous 
work~\cite{CDHR2002,CDCR2002,RSS2002}.

\subsection{Algorithms for Structured Architectures}

%###############################################################################
%###############################################################################
%###############################################################################
%       GEOGRAPHIC LAYOUT
%###############################################################################
%###############################################################################
%###############################################################################

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Global Soft-State}

% \begin{figure*}
% \centering
%   \includegraphics[scale=0.8]{img/algorithms/global_softstate}
% \caption{(left) Position of $p$ in the space of $3$ landmarks. (right) Position
% of $p$ on the map.}
% \label{fig:global_softstate}
% \end{figure*}

\textit{Global Soft-State} \cite{XTZ2003} builds a global map to help
choose shorter routing paths, combining the landmark binning method and small
scale distance probes to reveal the proximity properties of the underlying
network to the overlay. %Figure \ref{fig:global_softstate} presents the landmark
%space and the mapping of the position of the nodes.
This global view of the
state is made available to all nodes to help them find the best way to
route their messages. \textit{Global Soft-State} operates in two phases: 
generation and use of the proximity information. For generating the proximity
information a hybrid approach is proposed, which uses landmark clustering as a
preprocessing step to select a number of potential nearest neighbor
candidates and then refine the selection by incorporating a
round-trip-time-based scheme to ultimately choose the closest node. For using
the proximity information, the algorithm chooses a different path from the
classic gossiping approaches for constructing and maintaining the overlay. It is
based on landmark clustering for strategic placement of proximity information on
the overlay enabling any node to access such information using a landmark number
that reflects its physical position in the network. For various logical
regions\footnote{This might be a high-order zone in the eCAN\cite{xu_ecan_2002}
context or a set of nodes sharing a particular prefix in overlays such as
Pastry\cite{antony_pastry_2001}.} maps of physical information are built and
published where each node may appear in a maximum of $log\left( N \right)$ such
maps. To dynamically adapt to changing network conditions, a node subscribes to
relevant \emph{soft states} that utilize a notification system in order to
initialize any necessary neighbor re-selection.

Maintainece of several host states at different layers, renders any content
migration a costly process. Additionally, the method does not make any
continuing effort to remap
the overlay structure after nodes successfully join resulting into poor
adaptation to changing conditions. Although this approach greatly reduces the
routing latency to far nodes, it is unable to dynamically identify nodes that
are close to routers and gateways in order to construct the secondary overlay.
Nevertheless, static recognition of such nodes is currently done based on BGP
reports and pre-chosen landmarks, sacrificing the self-organizing attribute of
traditional DHTs.

%
% TODO: SOME DISCUSSION
%
% Xu \textit{et al.} \cite{XTZ2003} state that there are three ways
% generating proximity information
%\begin{itemize}
% \item Expanding Ring Search\\
%Expanding ring search can be of two forms. First it can utilize the multi-cast
%infrastructure in the underlying network in order to emit its messages.
%Unfortunately such infrastructures are not widely deployed thus the
%implementations of this way of generating proximity information is limited to
%blindly flooding the neighborhood to obtain reasonable results.
%
% \item Heuristics\\
%Heuristics are used in order to reduce the blindness of the expanding ring
%search and make realizations more efficient and effective. Unfortunately a
%common problem of all heuristic approaches is the local minimum pitfall in
%which
%the search might be caught into.
%
% \item Landmark Binning\\
%Landmark clustering is based on the view that nodes with similar distances to a
%set of predefined well-known landmark nodes are pretty likely of being close to
%each other. But this approach has its weaknesses as well, such as the fact that
%is a rather coarse grained approximation, therefore not particularly well
%suited
%for differentiating nodes within close distance to each other.
%
%\end{itemize}
%
%

%
% TODO: IN PAPER INTRODUCTION A DISCUSSION ABOUT
%TOPOLOGY-AWARE CAN
%
%Techniques to exploit topology information in overlay
%routing include geographic layout, proximity routing and
%proximity neighbor selection [3]. With geographic layout
%such as topology-aware CAN [12], the overlay structure is
%constrained by underlying network topology. This tech-
%nique, unfortunately, can create uneven distribution of
%nodes in the overlay, increasing the chances of overloading
%nodes and rendering the maintenance cost formidable. Our
%study shows that, for a typical 10,000-node topology-aware
%CAN, 5% nodes occupy 85-98% of the entire Cartesian
%space, and some nodes have to maintain 450-1500 neigh-
%bors. In Proximity routing, physical topology is not consid-
%ered when constructing the overlay.
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Unable to identify nodes that are close to routers but it can reduce routing
% latency to far away node by approximately 50-75%.
medium &
% maintenance of node states, subscriptions and notifications need global
% overview of the overlay resulting in high control overhead
high &
% Statically implemented sacrificing the decentralized nature of DHTs and
% thus poorly scaling.
low
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Mithos}
\emph{Mithos} \cite{WR2003} is a P2P protocol which incorporates directed
incremental probing to find near optimal node placement, and is an integration
of geographic layout and proximity routing overlay optimization methods.

The bootstrap phase of \emph{Mithos} starts with a subset of existing members as
the first set of candidates, and while the iteratively closest nodes are detected by
probing the neighborhood, the candidate neighbor list is updated. To
avoid a local minima, Mithos probes all the neighbors within a two-hop distance
from the current minimum before concluding the process.

After finding its first neighbor, the newcoming peer is assigned an ID using
information gathered during the iterative neighbor selection phase. Virtual
coordinates are assigned to the newcoming peer by using the distances of the two
closest nodes and their neighbors, so that Euclidean distances between the node
and all known hosts predict the network latency between them
\cite{cox_vivaldi_2004}. The benefit of these synthetic coordinates are that
they are explicitly used as the node's ID, and distance computations among nodes
can be done in ID space without requiring physical measurements.

The last step of the algorithm is the interconnection among neighbors. Mithos
uses a \emph{quadrant-based} mechanism in which each node establishes
a link to the closest neighbor in each quadrant. During forwarding, the next
hop is performed towards a neighbor in the same quadrant as the final
destination. The new coming node may not know of other neighbors in all
quadrants, therefore, the node first identifies neighbors in all quadrants
using a mechanism based on ideas similar to a perimeter walk\footnote{Used in
the Greedy Perimeter Stateless Routing (GPSR) protocol.} and then improves the
results using parallel path processing by taking into account further geometric
properties of node relationships.

One major limitation of \textit{Mithos} is that the protocol cannot handle
dynamic arrivals and departures from the network.


%
% TODO: review this part
%
%In order to avoid local minima during neighbor detection, extensive probing
%  must be undertaken. In simulation, unfortunately, only very small-sized
% overlay topologies (of 200 to 1000 nodes) have been used and thus no safe
% conclusions can be made as for the behavior of an extensively large,
% real-world p2p deployment of the scheme.

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% It has very good results in reducing communication latency among peers but its
% efficiency is being constrained by the fact that the proximity is calculated
% at bootstrap, assigning virtual coordinates that are used throughout of a
% nodes life cycle and thus the overlay is not adapting to a high-churn
% environment.
medium &
% Incremental probing is applied in quadrants and in two-hop distance at each
% step that does not generate a lot o control overhead.
medium &
% It is constrained by the fact that the protocol does not respond to dynamic
% peer arrivals and departures
low
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{LAPTOP}
\emph{LAPTOP} \cite{WLH2007}, organizes the overlay into a tree-based hierarchy
with the goal of reducing hops during message routing as well as minimizing
maintenance overhead. Additionally, a caching scheme is also incorporated so as
to further reduce routing table update costs. The authors theoretically show
that in LAPTOP, routing path length is bounded by $O(log_d N)$ and node joining
and leaving in the overlay network is bounded by $O\left( d log_d N \right)$
hops in a balanced overlay tree, where $N$ is the number of nodes, and $d$ is
the maximum degree of each node. LAPTOP implements the geographical layout
approach  and constructs its layout in a self-organizing and efficient fashion.
The physical distances are estimated with round trip times to a few existing
nodes in the overlay network.

Each node is assigned a dot-formated address (e.g 1.3.4). Each octet ranges from
$1$ to $d$, where $d$ is the maximum degree of the nodes. The assignment process
is done by appending a unique octet to the address of each node's parent, while
the root node is assigned address $1$.

%The protocol is based on four definitions.
%\begin{enumerate}
% \item The amplitude of all possible measured RTTs is divided into intervals.
%  Each node measures its distance to its parent and is assigned a label $L_i$
% where $i$ denotes the configurable RTT interval in which the measured distance
% falls into. A special kind of node, the root, is initially assigned the $L_1$
% label and maintains (as all $L_1$ nodes do) a list of other $L_1$ nodes in the
% overlay.
% \item Any node can have children with level lower than theirs, except an
%  $L_{max}$ node which can only have $L_{max}$ level children and only in the
% case when its parent has reached its maximum degree.
% \item Each node is assigned a dot-formated address (e.g 1.3.4). Each octet
% ranges from
% $1$ to $d$, where $d$ is the maximum degree of the nodes. The assignment
% process
% is done by appending a unique octet to the address of each nodes parent, while
% root node is assigned address $1$.
% \item For any descendant node $Y$ of a node $X$, the measured distance among
%  each other, must always be less than the lower bound of the RTT interval
% denoted by $X$'s label.
%\end{enumerate}
%

The routing scheme is similar to the longest-prefix IP matching scheme. At each
forwarding hop, any message travels up the tree until the first common ancestor
of both source and destination nodes is reached and then starts descending to
arrive to its target. During tree traversals, special entries in the routing
tables, called \emph{routing cache}, are maintained to increase routing
efficiency and achieve finer load balance. Caching enables a node to forward a
message to a better longest-prefix match than that of its direct ancestor making
a larger, quicker and more cost effective step through the overlay and toward
the destination. To improve scalability, the number of child nodes and the
size of the routing cache are limited. In terms of overlay maintenance, LAPTOP
incorporates a simple \emph{heartbeat}-based technique where each parent node is
responsible for monitoring its children.

%
%The new comer $N$ locates the root node and the later responds with a list of
%  $L_1$ nodes. $N$ then probes each of the $L_1$ nodes in search for the
% closest one. If the measured RTT to the closest $L_1$ falls into the first
% interval then the new comer becomes a $L_1$ node as well. Otherwise node $N$
% sets the closest $L_1$ node as its potential parent node. This potential
% parent becomes the actual parent if it does not have any other children. If it
% has, $N$ gets a list of these $L_i$ nodes and by measuring the RTT to each of
% them tries to spot a new potential parent in order to repeat the above
% process.
%

% At join process the new coming node is assigned its level label as well as its
% address by its parent node. Additionally, it initializes its routing table
%(with normal and caching entries) as it traverses the overlay in search for
%its parent node.  During a graceful departure, the referred node checks for
%children in the overlay. If it does not have any, it simply notifies its
%parent and leaves. If it has, it selects the child node with the lowest
%round-trip time to it in order to take its place so that the locality
%property is preserved. On the other hand, in the case of an arbitrary
%failure, after the children of the failed node detect their parent's absence
%(through the aforementioned heartbeat mechanism), they start emitting special
%messages to their grandparent node (the address of which is stored during
%join process}. In case of no response from the grandparent node, the children
%invoke the joining process to detect their new parent node.The parent of the
%failed node, aggregates the notifications from the above children nodes for a
%period of time, and then chooses the one with the lowest level label as the
%takeover node. Potential ties are broken by favoring the lower RTT. The
%parent of the failed node, finally informs accordingly all the children about
%the change in the hierarchy.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% TODO: HERE STRUCTURED LANDMARK BINNING APPROACH LIES
%
%Assuming a structured approach based on CAN\cite{ratnasamy_can_2001} and $m$
% landmark nodes. The coordinate space is then partitioned into $m!$ equally
%sized portions, each corresponding to a single ordering of the landmarks. To do
%this, the first dimension is divided into $m$ areas each of which is further
%divided (second dimension) into $m - 1$ sections and so on. Having set this $m$
%dimensional space, at joining time, a node measures the delay to the set of
%landmarks in order to determine its associated bin and thus position itself in
%that portion of the coordinate space associated with its landmark ordering.
%Even though this scheme can
%


\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% It minimizes routing length, but may suffer load imbalance since nodes higher
% in the tree hierarchy are more likely to route most of the messages in the
% overlay.
medium &
% Heartbeat approach incurs extra control overhead to the network. Fortunately
% involves only the parent and the children of the departing/failing node.
% nodes.
low &
% Seems to scale nicely from 10K- to 1M-node testbeds.
high
\end{tabular}
\end{center}



%###############################################################################
%###############################################################################
%###############################################################################
%       PROXIMITY ROUTING
%###############################################################################
%###############################################################################
%###############################################################################


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Proximity in Kademlia}
% Before discussing {\em Proximity in Kademlia}, it would be helpful to briefly
% summarize the highlights about the {\em Kademlia} protocol. {\em Kademlia}
% \cite{maymounkov_kademlia_2002} is a distributed hash table (DHT) based
% protocol for P2P networks, which uses an iteration based lookup algorithm. The
% protocol uses the standard $160$ bit ID system for nodes and locates the nodes
% in a prefix binary tree, where IDs are used as prefixes. The iterative lookup
% operations are done over this prefix binary tree, which converges to
%logarithmic
% lookup times. The ID's are assigned randomly, therefore in Kademlia, there is
%no
% proximity control, which results in inefficient use of the underlying network
% during lookup and retrieve operations.

\emph{Proximity in Kademlia} \cite{KLKP2008} introduces proximity
controls over the vanilla Kademlia protocol's random ID assignment to
optimize the underlying network usage of the protocol. The work in this paper
can also be considered as a more generic study of incorporating proximity into
iterative lookup algorithms. 
The overlay tier improves its routing
performance using a cost metric that is provided by the underlying tier
and quantifies the suitability of establishing a communication link between peers as
a cost function, based on the used proximity criteria (RTT, ISP locality, etc.).
%An underlay metric provides information about the underlay network. The paper
%  distinguishes between three kinds of possibilities to quantify it:
%\begin{itemize}
% \item Using measurements gained by previous lookups
% \item Using measurements acquired by other peers or jointly calculated with
%  others
% \item Using a local database to look up information
%\end{itemize}

The paper proposes two approaches for overlay optimization: 
{\em proximity routing} and {\em proximity neighbor selection}.
In proximity routing, the goal
is to choose the best next hop during routing a message. Due
to the fact that the routing in Kademlia is iterative, it is the initiator of
the lookup that chooses each next hop from a set of candidate nodes. Standard
Kademlia always chooses the closest node with respect to the XOR metric but with
proximity routing selection, Kademlia chooses the node with the smallest underlay
metric cost. Thus, as in all such approaches, there is a trade-off between the
overlay and underlay distances.

Towards the enhancement of traffic locality, the authors also use information
from the MaxMind GeoIP database\footnote{MaxMind Geolocation Technology.
http://www.maxmind.com} to retrieve proximity information of a given peer based
on its region, country, or ISP location, and use this information to form
clusters of nearby peers. An alternative method could use Vivaldi
coordinates \cite{cox_vivaldi_2004}. However, the authors report that their clustering
approach performs better than the Vivaldi protocol based on their experiments.
Authors also report that {\em Proximity routing} protocol successfully worked
with the Kademlia protocol and improved the locality of the connections between
peers.

In \emph{proximity neighbor selection}, the goal is to
keep peers with the least contact cost in the routing table. As Kademlia
continuously learns about new peers via incoming requests and an iterative
lookup process, no 
special algorithm for searching more cost-effective peers is necessary and
it simply chooses the best peers seen so far.

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Uses static information to cluster nodes which is not the most efficient
% approach in dynamic systems
medium &
% 
medium &
%
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{CHOord considering Proximity on IPv6 (CHOP6)}
\emph{CHOP6} \cite{MT2007} roughly estimates the proximity among
nodes by exploiting the IPv6 address format and RTT information if available.
The proximity estimation is achieved by introducing a 64-bit ID scheme in which
the least significant bit part is the IPv6 global routing prefix and thus
enabling a longest prefix match scheme. The protocol is designed based on the
observation that it is possible to estimate a node's geographical location by
simply examining the upper 32-bits of its IPv6 address. Moreover, similar to
Chord\cite{stoica_chord_2001}, CHOP6 uses a finger table, whose entries hold
more than one candidate node.

%
%\paragraph{}
% There are three cases in which a node chooses the next hop according to
% information it possesses.
%\begin{itemize}
% \item When no information about RTT is available candidate next hops, the
%  sender just selects a node in the finger table entry which shares the longest
% prefix with the destination.
% \item There is another possibility that after some communication with other
%  nodes, the source node should know of the RTTs to some of the nodes in finger
% table entry. In this case, the source node chooses the one with the smallest
% RTT with probability $p$. If there is a node with no measured RTT then the
% sender can select such a node with probability $1 - p$
% \item In this last case the source node has already communicated with all
%  candidate node in the finger table entry. Thus, the node selects the node
% whose RTT is the smallest with probability $p$, the one with the second
% smallest with probability $q$ and so on, where $0 \leq \ldots < r < q < p < 1$
% and $p+q+r+\ldots \leq 1$
%\end{itemize}
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Simple approach that exploits proximity but it is coarse grained and thus not
% efficient.
low &
%
low &
%
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{T2MC}

T2MC \cite{SLCGZ2008} uses traceroute logs to detect the AS boundaries and
cluster nearby peers together to reduce the redundant multiple message
passes between the AS boundaries. T2MC uses a customized k-mean classification
algorithm with k = 2 to perform the classification, and exploits the stable
structure of the internet routers to guide clustering. Even though traceroute
provides detailed information about the network structure, use of traceroute
creates overhead on the overall network structure. For this same reason, it is
not unusual for network administrators to disable this support on their network
routers, which may affect the performance of the T2MC algorithm.


%T2MC \cite{SLCGZ2008} uses trace-route logs to detect different autonomous
%systems and cluster close by peers, thus reducing redundant traffic that crosses
%autonomous system boundaries. T2MC uses a customized k-mean classification
%algorithm with $k=2$ to perform the classification, and exploits the stable
%structure of the Internet routers to guide clustering. The peer chooses the
%minimum and maximum Latency results from the trace-route to initialize the
%centroids of two sets. Then the peer calculates, for all hops along its
%trace-routed path, the peer calculates the absolute distance to these centroids
%of both sets and assigns the routers to that centroid with which it has the
%smaller absolute distance. After that, the mean and variance values are
%calculated and if the variance is larger than a predefined threshold then the
%algorithm sets the two latency mean values as new centroids for the two sets and
%loops again. Ultimately peer will end up with two sets having the minimum
%intra-set variance. The peer, then, chooses the router from the second set with
%the minimum hops attribute and sets it as a threshold. The selected router and
%all others whose hops attribute is larger than the threshold are classified as
%\emph{remote} router cluster. The remaining are classified as \emph{near}. From
%the near class, the peer chooses the one with maximum hops attribute as its edge
%router, and registers it along with all near clusters into the DHT of the
%P2P overlay. As new peers join the network, those that share the same edge
%router or any of the members of the near router clusters, would form a close
%peer cluster. As Edge routers can provide more valuable information than other
%members of the near set, T2MC was designed to prioritize interaction of peers
%and edge gateways.

%
% TODO: SOME DISCUSSION
%
%The use of Trace-route as a tool for implementing the distance measuring
%infrastructure raise concerns about its efficiency and scalability. Being,
%primarily, a network diagnostic utility,
% Even though trace-route provides detailed information about the network
% structure, its excessive use creates additional overhead that stresses further
% the overall network infrastructure. This forces network administrators to
% disable its support from the routers they manage, thus jeopardizing the
% effectiveness of the T2MC algorithm.
%


\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The efficiency of choosing close by peers is very good and reported almost
% 65\% better than that of GNP (and thus generally of static landmarking as a
% whole)
high &
% trace-route is a very heavy tool and thus incurs excessive burden to the
% network resources.
high &
% Trace-route is categorized as too heavy-weighted and intrusive for use in a
% larger scale system \cite{RHMKS2002}. Additionally, disabling
% ICMP is a common administrative policy for edge sites to enforce security,
% while dumping BGP routing tables\cite{krishnamurthy_bgpclust_2000} is not
% directly available to the application layer.
low
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{PChord}
\emph{PChord}\cite{HLYW2005} is based on the Chord DHT and adds
proximity routing into its routing mechanism. The main modification over the
vanilla Chord is the inclusion of a \emph{proximity list} into its routing table
so that the next hop is decided based on both the best progress
towards the key and the physical proximity of the candidate nodes as well.
The list is, at join time, empty but as the PChord node starts to interact with
other nodes it applies a heuristic mechanism to fill the list. Entries are
dynamically added or removed as the network state changes. The overlay
maintenance cost can be considered similar to Chord's. Besides node join/leave
and cost of heartbeat messages for connection verification, PChord adds
heartbeat of nodes inside the proximity list but since this list always contains
nodes with the lowest RTT the added cost is kept to a minimum.

Due to the fact that, with each step, there is always progress towards the
target node in the ID space, PChord will result in a reduced hop number than
Chord, since each hop in PChord is larger or at least equal in the key space.
Passing through proximity links in the underlying network means reduced routing
cost. Additionally, if the number of entries in the proximity list is the same
as the number of network partitions, PChord prevents hops from jumping in and
out of the network partition the current node belongs to.

% TODO: SOME DISCUSSION
% TODO: NEEDS REWORDING
% PChord’s main routing optimizations are of less overlay hops, passing
% proximity links of the underly network and passing the same network partition
% only once in the routing path, which directly results in the lower RDP of
% routing efficiency. Meanwhile, PChord keeps light-weight maintenance cost as
% Chord does.


\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Small decrease in needed overlay hops per object publishing
medium &
% The are heartbeat mechanism for both finger table and proximity list adds a
% burden to the network by default. But the overall overhead is decreased as
% the proximity list becomes longer.
medium &
% Improvement of routing is achieved with more object pointers helping to
% shorten the routing path of object querying. When the distance of query source
% to target is far away both Chord and PChord achieve the average hop number to
% not increase.
high
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{AChord}
\emph{AChord} \cite{DK2006} uses IPv6's anycast mechanism to
relieve the protocol from complex joining procedures, and achieve high accuracy
of network proximity and thus, high routing efficiency. Anycast delivers a message
coming from the outside of an anycast group to the physically closest node in
that group. AChord organizes all nodes participating in the overlay network into
an anycast group. Any joining node comes outside of that group and, thus, is
automatically forwarded to the physically nearest node in order to bootstrap,
avoiding the need to, explicitly, maintain such nodes, and the effort of finding
a way of locating the physically nearest among them. The ID of the newcoming
node is computed based on the ID of the bootstrap node and the bootstrap's
predecessor in a way that the constructed ID will be positioned between the
aforementioned two. After joining, the finger table is built the same way as in
the Chord protocol. Moreover, additional nodes are maintained in a structure
called \emph{adjacency table} which stores information about the closest known
node. The routing decision is made by using both the adjacency and the finger
table. The authors claim this to be a lightweight approach that requires few
changes to Chord while keeping its advantageous characteristics.

% TODO: MAYBE REVIEW THE EVALUATION
\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% good routing efficiency
medium &
% Relieves the system from joining overhead and topology aware ID construction
% but doubles the information needed to be stored and maintained by the
% introduction of adjacency table
medium &
% assumes the operation of ideal underlying anycast mechanism (meaning that
% outside messages are always routed to the nearest node which in the current
% Internet, this is not always feasible. Moreover, is designed on the basis of
% IPv6 protocol which is not widely operational yet.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Chord6}
\emph{Chord6} \cite{XZHL2005} is another Chord variant that tries to
exploit the hierarchical features of IPv6 to create a substrate that
reduces inter-domain traffic between service providers. The difference between
Chord6 and Chord relies on the identifier definition. Therefore, the approach
can be easily portable to other DHTs such as CAN, Pastry and Tapestry. In Chord6
the identifier contains two parts: the higher bits are obtained by hashing the
node's IPv6 address prefix of specific length, while the remaining lower bits
are the hash value of the rest of the IPv6 address. As a result of this
assignment, nodes in a domain will be mapped onto a continuous key space on the
overlay network, which avoids unnecessary message forwarding across different
service providers, thus minimizing overall routing cost.

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% Can reduce intra-domain average path length but even though nodes in the same
% domain would have close identifiers, nodes in two close domains may have very
% different ones reducing the overall efficiency of the approach in general when
% considering inter-domain average path length.
low &
% The construction of the identifier space is done at node join and in an
% independent fashion involving the application of two hash functions meaning
% resulting in low overhead stress to the network and its nodes.
low &
% Is designed on the basis of IPv6 protocol which is not widely operational yet.
medium
\end{tabular}
\end{center}

%###############################################################################
%###############################################################################
%###############################################################################
%       PROXIMITY NEIGHBOR SELECTION
%###############################################################################
%###############################################################################
%###############################################################################

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{DHT-PNS}
The work in \cite{DLTZZ2006} propose a proximity neighbor selection
scheme on top of the Chord DHT. The main goal is to use proximity information
to group physically close by nodes as neighbors in the DHT table. In order to
detect proximity, virtual network coordinates of peers are used, by using the
Vivaldi protocol \cite{cox_vivaldi_2004}. The virtual coordinates are then used
by the nodes to map to identifier space in the DHT. The space is partitioned
using a \emph{concentric circle clustering scheme} where successive cycles of
radiuses $\rho$, $2\rho$, $3\rho$ and so on, are constructed. Then the formed
annuluses are divided into $2\chi-1$ \emph{sectors}, where $\chi$ denotes the
sequence number of the annulus starting from $\chi = 1$ for the center cycle. It
is proved in the paper, that this way each sector occupies the same area as does
the center cycle. Assuming uniform node distribution, this characteristic,
favors a more load balanced clustering operation. Every sector in this $2d$
coordinate space is mapped to a unique \emph{region} in the DHT space forming a
multi-layer node identifier space.  Thus, any nodes that belong to the same
sector, are mapped to the same region as well, preserving their proximity
relationship unveiled by the use of the Vivaldi protocol. The individual pieces
are mapped to the identifier space uniquely, allowing logarithmic lookup
operations with high probability on Chord. The system described in the previous
section allows any node to obtain its DHT key and its region key, in a fully
distributed manner, just by applying a consistent hash function. Using an RPC
call in Chord, the node can obtain the region's master node, called
\emph{Cluster Node (CN)} which is responsible for clustering the nodes belonging
in the same sector or region with that of the node at hand. An additional RPC
call, registers it to its corresponding region and publishes its information,
through the special peer CN. The node can, additionally, ask CN for other
nodes that have previously joined the region to add them into its
neighbor set for future routing table optimization. Even in the case when no
neighbor is detected in the current region, the search is expanded to adjacent
regions and towards an upper layer identifier space until one is found or the
first layer reached.

% TODO: MAYBE REVIEW THE EVALUATION
\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
%
medium &
%
medium &
%
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Quasi-Chord}
The approach that is proposed by Sun and Zhang in \cite{SZ2008}, tries
to address the topology mismatch problem, at the construction phase of the
Chord identifier cycle, on the basis of underlying topology information.
The proposed model constructs the \emph{Quasi-Chord} overlay network in three
steps. First, each host acquires its coordinates in the geometric space
utilizing the \emph{global network position (GNP)} protocol \cite{ng_gnp_2001}.
Second, using the \emph{Cantor space filling curve}, the $2$-dimensional space
is converted to a $1$-dimensional one, used in the last, third, step to build
the Quasi-Chord circle according to the host's Cantor value. In Quasi-Chord
each node stores 2 finger tables; one clockwise and one counter-clockwise.

%In the following paragraphs, these steps are further discussed.
%
%\paragraph{GNP coordinates}
%First of all the host must be positioned in the geometric space. The algorithm
%  models the P2P network with a well defined distance function in such a way,
% it can predict, with high accuracy, the distance between any two points in the
% space by just evaluating the output of the distance function on the
% coordinates of these points. This is accomplished with the \emph{global
% network position (GNP)} protocol which\begin{inparaenum}[\itshape i\upshape)]
%  \item creates a reference set of $N$ landmark nodes so as to minimize the
%  error of ICMP measured distances and coordinate computed ones between them,
% and then
%  \item each host is able to measure its round-trip times to the $N$ Landmarks
% in order to compute its own coordinates.
%\end{inparaenum}
%
%\paragraph{Cantor SPF}
%After the $2$-d coordinates are set, in the next stage of the algorithm, each
%  participating peer is assigned a Cantor value, according to the application
% of a \emph{space filling curve} on the coordinate space. (TODO: add figure).
% This results in the conversion of the $2$-dimensional space to a
% $1$-dimensional Cantor space that can more easily be more mapped to the Chord
% hierarchy.
%
%\paragraph{Quasi-Chord construction}
%As can intuitively be inferred by observing the Cantor chart, close-by nodes in
%  the physical layer, are more likely to have similar Cantor values. This
% attribute is exploited in order to construct a topology-aware identifier space
% for the Chord DHT. The cycle is constructed by sorting nodes in ascending
% order. Each host maintains 2 finger tables, one for clockwise and one for
% counter-clockwise stepping. This helps with the connectivity of the network
% because its not allowed to connect the first node with the last one since this
% will incur heavy traffic to the later\footnote{After all their Cantor values
% denote that they are actually the furthest of each other.}.
%

%
% TODO: SOME DISCUSSION
%       NEEDS DOUBLE-CHECK
%
%The disadvantage of the algorithm is that the coordinate assignment in the
%  first stage is backed by a not fully distributed landmark-based algorithm.
% Moreover the Quasi-Chord model build-up is making an indirect assumption of a
% maximum number of allowable hosts since it is constructed. Last but not least
% the doubling of the required routing information which needs to be created and
% maintained is an additional negative point to the efficiency and the
% scalability of the algorithm.
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The algorithm shows to reduce end-to-end delay as well as not produce
% duplicates of messages.
medium &
% The overhead is more compared to vanilla chord since mapping of 2-dimensional
% space to 1-dimensional with Cantor SPF adds some extra burden in time
% complexity. Also the addition of the counter-clockwise finger table doubles
% the data, per se, needed to be stored and maintained.
high &
% The GNP system is a static landmark approach making things not fully
% distributed and thus constrain the model's scalability.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{IP-based Clustering (IPBC)}
Proximity neighbor selection algorithms use probing and other techniques to
detect proximity. However, such methods are either not precise enough, or
overload the network. \emph{IP-based clustering} \cite{KM2007} is a proximity
neighbor selection based algorithm in which the authors propose to use the IP
address prefixes (16 bit for IPv4) in order to detect proximity.
\cite{freedman_iploc_2005} states that $97\%$ of prefixes larger than $24$ bits
belong to a single geographical location. However, using a smaller number of bits
creates less precise results and a larger number of bits increases the burden on the
network and reduces the possible number of neighbors. Therefore, a careful
selection is required in terms of performance/accuracy trade-off. IP-based
clustering generates a key and its prefix and stores the prefix in the DHT
itself, so that any newly joining nodes with the same IP prefix can query it and
identify all the neighbors with the same prefix easily.  Nodes
periodically update their entries in the DHT by removing those who leave, or
those who have been timed out with no further activity detected from the node.

% Moreover, observing the
% \emph{IANA IPv4 Address Space Registry} we can infer that, since blocks of
% consecutive octet prefixes are assigned to the same Regional Internet
% Registries (RIRs), nodes inside will be physically close to each other.

%
% In order to be published in the overlay, each node is first assigned a
% unique identifier and subsequently generates a key by hashing a fixed-length
% prefix of its IP. Authors argue on the prefix length to be used, as there is a
% thin balance between reducing the probability of finding closer nodes by
% adopting a long prefix and overload nodes that are responsible for information
% published by many peers when choosing to hash a short one. Their verdict is
for
% the use of a 16-bit wide prefix for real world systems deployed in an Internet
% scale. In either case, ID and IP is then stored in the DHT using this
% generated key. This way, any node, at any time (either at join time or during
% peer lifetime for topology adaptation) can acquire information about close-by
% nodes just by querying the DHT for a specific key. Moreover, the algorithm
% takes care of the freshness of the proximity information in two ways. First,
% the advertising nodes themselves periodically update their advertisements or
% when they voluntarily leave the overlay, they explicitly remove their data. On
% the other hand, in case of a failure each publication is assigned an
% expiration time, and thus ultimately removed by the DHT maintenance
%mechanisms.
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The efficiency of proximity detection through the prefix matching technique
% is caught in a vicious cycle with the storage space needed for DHT object
% publishing (how many bits will be used for either)
low &
% The overhead for detecting proximity is only comparison of prefixes
low &
%
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Cone}
\emph{Cone} \cite{HY2007} extends Chord using a proximity neighbor
selection topology optimization algorithm. The proximity information is
generated using landmarks and round-trip-time-based distances to landmarks.
Cone uses a two-layered identifier space. The first, named Chord-layer
identifier, denoted as $Id_{Chord}$, is the same as in Chord. The second is the
Cone-layer identifier, $Id_{Cone}$ which is constructed using two component
identifiers. The first, known as \emph{group identifier (gid)} denotes a
relevant group to which the node belongs while the second, namely \emph{local
identifier (lid)} indicates the local identifier within the group. The group
concept is a way of dividing nodes according to a
common $Id_{Chord}$ prefix.  The structure of a Cone overlay, retains the
Chord's circular topology. The difference lies in the fact that, now, two rings
are created. A big ring, where nodes with the same \emph{gid} are arranged at
each position. Each of these positions are a smaller ring for the particular
group's \emph{lid}s. Routing is achieved in both clockwise and
counter-clockwise directions in the big-ring, for which two routing tables are
maintained, namely \emph{front} and \emph{back} finger tables. Entries in these
tables, display physical network proximity with the current node. Moreover, a
third table called \emph{group} maintains information about other on-line peers
within the current node's group in a way that entries are now close in the ID
space.

%
%Routing in Cone, comprises of the inter-group algorithm and the intra-group
%  algorithm. First the group of nodes to which the desired key lies is
% detected, exploiting physical proximity information (front and back finger
% tables). Second during the next and last hop, the message is forwarded to the
% exact node that contains the desired key.
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% The result of experiments show that the Cone, compared with Chord, has obvious
% improved on the delay of route and the hops of overlay networks…
medium &
% The approach incorporates a static landmark + RTT to these landmarks in order
% to exploit proximity information thus incurring low overall additional
% operational overhead but imposing extra stress to the landmarks themselves 
medium &
% landmark based approaches are not full distributed thus not smoothly scalable.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{DynaMo}
\emph{DynaMO} \cite{WZS2004} tries to build an overlay that not only 
considers physical proximity amongst peers but their mobility attributes as well.
DynaMO is based on the Pastry overlay
because of Pastry's built-in locality
heuristics which are thoroughly analyzed in the literature \cite{CDCR2002a}.  
To adapt to mobile, ad-hoc networks, though, special care has been put in 
the maintenance of an even overlay ID distribution so that hotspots are
avoided. DynaMO requires a newcoming node to gather information concerning its
physical neighborhood and uses it to assign itself an appropriate overlay ID.
DynaMO tries to capitalize on the fact that in Pastry each node's table consists
of rows equal to the number of digits in the overlay ID and columns equal to
the ID's base. As we go down the table rows, the matching prefix between the
current node's ID and the row's entries increases by one. Thus, the leaf set
contains the closest nodes in the ID space. Additionally, as the prefix match
increases by one, the result is exponentially fewer candidates that can fill the
tables entries as the row increases. This leads to the observation
\cite{antony_pastry_2001,CDCR2002a} that from overlay routing hop to overlay
routing hop, the physical distance between nodes is likely to increase leading to
a dominating last routing step in terms of the overall physical routing path
distance traveled during a key lookup. Since the last routing step is usually
taken from the leaf set, DynaMO focuses on making this last step as physically
close as possible. In this context, two approaches are considered namely
\emph{Random Landmarking (RLM)} and \emph{Closest Neighbor Prefix Assignment
(CNPA)}.

The RLM lookup mechanism is used to locate nodes responsible for a fixed set of carefully
chosen (in a way that the ID space is divided into equal portions) landmark
keys. This means that when a node is assigned a landmark key, it plays the
role of a temporary landmark for the network. Any joining node will measure its
distance to this landmark node and assign to itself an ID consisting
of a prefix taken from the closest landmark and a remainder that could be
assigned randomly or generated by a mechanism that takes into account physical
neighborhood. The length of the prefix can be determined as
$prefix_length=|log_b k|$, where $b$ is the ID base and $k$ the number of
landmarks. The above scheme results in physically close nodes, forming regions
of common ID prefix that are likely to be close to each other in the ID space
and thus bringing a node's leaf set closer to itself. Additionally, the
advantage of dynamic landmarking is that in the case of failed landmark servers
they can instantly be replaced by new substitutes, that share similar physical
attributes with the failed and thus preserve the balance of the network.

RLM may incur more traffic especially on landmark nodes, load that in some cases
is not acceptable. CPNA on the other hand takes advantage of Pastry's
specification that a newcoming node is bootstrapped by a physically close
node.
The newcomer then assumes the ID prefix of that neighbor while the rest of the ID is 
generated similarly to RLM. Unfortunately, less overhead comes at the expense
of being more coarse-grained.

%
% TODO: SOME DISCUSSION
%
%Both algorithms, are protected against the formation of physical landmark
%  clusters or imbalanced ID distribution\footnote{More common during the
% initial formation of an overlay network} , by introducing the \emph{landmark
% gravitation range} as a threshold over which landmark keys are reassigned (for
% the RLM approach) or unutilized ID prefix ranges are detected and used (for
% the CPNA scheme) in order to balance the distribution of regions in the
% overlay.
%

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
%
medium &
% The paper suggests that this approach generates significantly lower overhead
% than the vanilla Pastry algorithm
low &
% Dynamic landmarking approach helps the scalability of the algorithm. The
% authors claim that the temporary nature of RLM's landmark nodes does not
% prevent them to maintain a good ratio in the presence of high landmark
% degression rates.
high
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{SAT-Match: Self-Adaptive Topology Matching}

% \begin{figure}[ht]
% \centering
% \subfigure[Example physical topology of nodes.] {
%   \includegraphics[scale=0.6]{img/algorithms/SAT_match}
%   \label{figure:sat_match:before}
% }\qquad\qquad
% \subfigure[(left) A jumps to B in order to match the logical topology to the
% physical. (right) State of the logical topology after the jump.] {
%   \includegraphics[scale=0.6]{img/algorithms/SAT_match2}
%   \label{figure:sat_match:after}
% }
% \caption{The SAT-Match algorithm.}
% \label{figure:sat_match}
% \end{figure}

\emph{SAT-Match} \cite{RGJZ2004}, similar to the other approaches in proximity
neighbor selection, uses probing to detect nearby peers and obtain proximity
information. However, as an additional feature, SAT-Match peers can do selective
jumps to adjust their positioning in the DHT, if it reduces the \emph{stretch}
of its one-hop neighborhood. The paper defines stretch 
$S = \frac{\bar{L_l}}{\bar{L_p}}$, where $\bar{L_l}$ is the average logical link
latency while the $\bar{L_p}$ is the average physical link latency, and uses it
a way to quantify the \emph{topology match degree} of the constructed overlay. For
the probing phase SAT-Match uses a small TTL value for the probing messages in
order to reduce redundancy \cite{jiang_lightflood_2008}. This process begins as
soon as the node joins the network using a DHT mechanism. Each probing message
contains information about the source and a small TTL value. The recipient of
such a message returns information about itself to the source and forwards the
probing message to its neighbors if the TTL is non-zero. The discovered nodes
are referred to as $TTL-k$ neighborhood of the source node based on the $TTL$
distance to the source node. Blindly selecting the peer with the smallest RTT
as neighbor is, generally, not the optimal decision to make to achieve
global stretch reduction. In a structured scheme, when a node jumps to connect
to a physically close node, it may need to connect to other distant nodes to
maintain the structure's integrity, thus creating an overall increase in the
overlay's stretch. The two nodes with the smallest RTT are then used to
select one zone to jump in this phase. The algorithm is as follows: The source
node $S$ calculates the stretch change of its $TTL-1$ neighborhood and that of
the $TTL-1$ neighborhood of the first of the previously selected peers. These
calculations are made as if the jump has been made. If the stretch reduction is
over a predefined threshold the jump is performed, otherwise the second selected
candidate is picked and the same computations are performed. If again, the
threshold is not met, then no jump is ultimately done. In case of a jump, this
is performed as a combination of \emph{leave} and \emph{join} operations, in the
CAN context. Even though no theoretical proof is given, valid results are
obtained and demonstrated through experimentations.
% Figure~\ref{figure:sat_match} demonstrates the selective jump on an
% example topology.

%
%\paragraph{}
%Moreover the algorithm takes several issues into consideration in order to
%  further improve the resulted overlay. For example when multiple nodes try
% to jump simultaneously into a region, then the logical link brakes from one
% attempt may result in inaccurate computation of the gain factor, for an other.
% This situation is identified as \emph{contention} and the nodes use an
% exponential back-off algorithm to avoid it. An other problem is the
%unnecessary
% traffic incurred by the probing phase in a region that after several jumps
% has settled to a stable state. In these cases it is more likely for jump
% attempts to be proven worthless. The algorithm doubles the probing period of
% such nodes, every time a jump is not taken.
%
%\paragraph{}
%The authors claim that this continuously adaptive mechanism achieves global
%  topology matching optimization in a sufficiently large scope. This also
% secures the fast adaptation to frequent network changes. It also considered
% lightweight and can easily be embedded into current p2p systems, as well
% as effectively combined with other techniques, such as landmark binning.

%
% TODO: SOME DISCUSSION
%
% It is reported that,
% due to the selective jumps, SAT-Match achieves $40\%$ reduction in
% link stretch, and when used with the landmark binning (see
% Sec. \ref{sec:landmark_binning}), the reduction rate increases up to $60\%$.
% For dynamic environments, with frequent node arrival and leave, SAT-Match
% scales much better than Mithos, due to its self adaptation mechanism and
% selective jumps.

\begin{center}
\begin{tabular}{ccc}
\emph{Efficiency} & \emph{Overhead} & \emph{Scalability} \\
\hline
% SAT-Match seems to outperform landmark binning in the sense of providing a
% higher grained differentiation of proximity, adding to the fact that
% SAT-match is fully distributed. Also to further enhance the efficiency it can
% work cooperatively with landmark binning itself.
high &
% distance probing and iterative computations add to the approach's overhead.
% Also the fact that the selective jumps are not always performed the added
% overhead to efficiency gained is not guaranteed in any configuration and
% circumstance.
medium &
% The self-adaptation nature of the algorithm and the selective jump mechanisms
% scale much better than, for example, Mithos.
medium
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discussion on the Algorithms for Structured Architectures}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Structured P2P network algorithms use a global distributed hash table or a
prefix tree structure to uniquely lookup peers or their data in the overlay
network. As all the data is kept within the overlay, each node behaves as a
client and a server, therefore nodes join and leave according to rules
determined by the integrity of the global data structure. The main advantage of
the structured P2P topology is that with the help of the global data structure,
peers or their data can be found within the network even if there is only a
single copy of that item present. However, each node join and leave creates
maintenance overhead for the network due to updates required by the global data
structure, and for networks with frequent node arrivals and departures, the
overlay uses valuable network resources just to update the global structure.
Nodes join the network by using a key value, which determines the location and
the neighborhood of the new node within the network. However, assigning
random key values to the newly inserted nodes creates non-optimal matching with
the underlying physical network topology, therefore, increasing the overhead of
the network even more. One solution for handling the topology mismatch problem
is to consider the proximity of the peers when generating the key and joining
the node to the network, so that nodes within the same network domains are
selected as peers, or neighbors, during the overlay topology construction.

This section gathered together some of the most distinctive research work that
can be found in the literature for addressing the inefficient network resource
utilization in structured architectures imposed by the topology mismatch
problem. A categorization of the methods used for achieving their goals is the
following based on previous work from
\cite{CDHR2002,CDCR2002,RSS2002}:
\begin{inparaenum}[\itshape i\upshape)]
  \item geographic-layout-based,
  \item proximity-routing-based,
  \item proximity neighbor selection based,
\end{inparaenum}

A quick overview can be obtained in Table~\ref{structured:table}. Topology
adaptation, landmarking and caching/replication have been visited during the
discussion on unstructured systems in Section~\ref{section:unstructured} so
we will not elaborate more here. As in the previous section, we provide the 
key properties of each algorithm that differentiate it from the others and
highlight 
each algorithm's advantages and disadvantages.

\input{structured-table}

\input{structured-plot}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Geographic layout} \label{section:geographic_layout}

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.4]{img/pdf/geographic-layout.pdf}
\caption{Successive nodes in the overlay circle can be chosen to be from the
same or near autonomous systems.}
\label{figure:geographic-layout}
\end{figure}

In the geographic layout category fall methods which practically
position physically nearby nodes together in the application space as well
(check Figure~\ref{figure:geographic-layout}). This is done by adjusting and
maintaining the routing tables of all involved peers by exploiting
proximity information that describe the overall geographic positioning of the
peer nodes. Landmark servers and RTT measurements are two popular methods, which
can also be used in conjunction, to discover physically nearby peers over the
network. However, as discussed in Section~\ref{sec:landmark_binning}, these
methods do not always give reliable estimates for the node positions over the
Internet. The landmark servers are not self-organizing and have maintenance
overheads. To serve a P2P network with millions of peers, multiple landmark
servers distributed over the whole world is required, which is hard to manage.
The RTT measurements also can measure the delay between peers, but it is a
greedy method, which can result in non-optimal overlay topologies especially if
close by nodes have low bandwidth connections among themselves.

Even though managing the overlay structure based on the geographic layout of the
nodes improves the query efficiency of the system, on the other hand, it tends
to create hotspots, and the needed failure resilience is undermined by the fact
that neaerby nodes are more likely to suffer collective failures.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% TODO: Geographic Layout
%
%\begin{itemize}
% \item Geographic Layout\\
%The node IDs are assigned in such a way that nodes close by in the physical
%network topology, be close in the node ID space as well. Implementations that
%work relatively well with this approach have been incorporated into CAN. Nodes
%measure the RTT between themselves and a set of landmarks in order to match the
%CAN space as much as possible to the physical one. Unfortunately, the approach
%requires well known landmark servers and for that matter is  not fully
%self-organizing which can further lead to imbalanced node distribution. On
%other DHTs, such as Chord or Pastry, another problem emerges.  To gain fault
%tolerant properties, these protocols, replicate key-value pairs on neighboring
%(in the ID space) nodes. When a proximity-based node ID assignment has been
%used, the needed failure resilience is undermined by the fact that close by
%nodes are more likely to suffer collective failures.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Proximity Routing}

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.4]{img/pdf/proximity-routing.pdf}
\caption{Proximity routing takes proximity information into account during the
routing process.}
\label{figure:proximity-routing}
\end{figure}

Proximity routing does not require routing tables to be built using any
knowledge about network proximity. On the other hand it exploits such knowledge
to choose the best next hop when routing a message as can be seen in
Figure~\ref{figure:proximity-routing}. This approach tries to balance between
choosing the node that will further progress the routing towards the destination
and choosing the closest entry in the routing table, in terms of network
proximity. As this is very difficult to achieve, the system might end up
using a greedy approach that selects low latency paths on the overlay, which
maps to suboptimal longer paths on the physical topology. Thus, in general,
proximity neighbor selection is considered as a superior method to proximity
routing, however, joint uses of these two protocols are also possible. Moreover,
they are considered relatively less effective than geographical layout when
applied to CAN(-like) implementations. Moreover, the technique has been
incorporated into a version of Chord causing an increase in the overhead of node
joins and the size as well as maintenance cost of finger tables.

%
%\cite{dabek_cfs_2001} proposes a server selection scheme for the Chord DHT, on
%the domain of proximity routing selection. In \emph{CFS}, each node predicts
%the entire lookup latency as a function of the total number of nodes and the
%average overlay next routing peer. The problem is that it is very difficult to
%have a clear picture on the total number of nodes and the average hop latency
%from the local. This leads to rough estimations that consequently decreases
%overall performance.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Proximity neighbor selection}

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.4]{img/pdf/proximity-neighbor-selection.pdf}
\caption{Proximity neighbor selection dictates that proximity is taken into
account during routing table maintenance.}
\label{figure:proximity-neighbour-selection}
\end{figure}

\emph{Proximity Neighbor Selection} constructs the routing tables using
proximity knowledge (see Figure~\ref{figure:proximity-neighbour-selection}). The
proximity information used in this method is different from the the
landmark-based systems described in Section~\ref{section:geographic_layout}.
Here time-to-live values between nodes, or directly node ID prefixes are used to
detect proximity. Tapestry, Pastry, and CAN successfully incorporated 
proximity neighbor selection into their algorithms. The routing protocol in
Pastry is based on longest node ID prefix matching, while CAN uses RTT values to
detect nearby nodes. \cite{CDCR2002a} reports that proximity neighbor
selection is an effective proximity based method.


% \item Proximity Neighbor Selection\\
%Finally, the third approach, constructs the routing tables using proximity
%knowledge. Tapestry and Pastry's mechanisms of routing table
%maintenance try to minimize the distance to nodes appearing in a peer's routing
%table. Since routing is based on longest node ID prefix match, messages
%are gradually forwarded to nearby nodes at each routing step.
%\cite{castro_proximityp2p_2002} argues on how Pastry exploits proximity
%neighbor selection in order to create a scheme that is (more) location-aware
%compared to the other well-known DHTs (CAN, Chord).
%
%\end{itemize}
%
%{\sethlcolor{yellow}\hl{
%HA: Possible criteria: based on which protocol (eg Gnutella, CAN etc), peer
%selection (topology selection, cluster, cache etc), supports dynamic update,
%runtimes}}
%%\textbf{Algorithm} & \textbf{Overlay structure} & \textbf{Forwarding} &
%\textbf{Cache} & \textbf{Overlay optimization} & \textbf{Proximity information}
%& \textbf{Base protocol} & \textbf{Dynamic update} & \textbf{Runtime} \\
%
%
%{\sethlcolor{yellow}\hl{
%HA: Possible criteria2: Overlay optimization structure, base protocol (eg
%Gnutella, CAN etc), dynamic update, runtimes, scalability}}
%
%{\sethlcolor{yellow}\hl{
%HA: maybe add also the year of publication, and see if there is a pattern in
%terms of the method and the year??}}
